/* automatically generated by rust-bindgen */

#![no_std]
#![allow(non_snake_case,non_camel_case_types,non_upper_case_globals)]
extern crate libc;

pub const __NEWLIB_H__: libc::c_uint = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"2.2.0\x00";
pub const _WANT_REENT_SMALL: libc::c_uint = 1;
pub const _MB_LEN_MAX: libc::c_uint = 1;
pub const HAVE_INITFINI_ARRAY: libc::c_uint = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: libc::c_uint = 1;
pub const _HAVE_LONG_DOUBLE: libc::c_uint = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: libc::c_uint = 1;
pub const _LDBL_EQ_DBL: libc::c_uint = 1;
pub const _FVWRITE_IN_STREAMIO: libc::c_uint = 1;
pub const _FSEEK_OPTIMIZATION: libc::c_uint = 1;
pub const _WIDE_ORIENT: libc::c_uint = 1;
pub const _UNBUF_STREAM_OPT: libc::c_uint = 1;
pub const _NANO_FORMATTED_IO: libc::c_uint = 1;
pub const __NEWLIB__: libc::c_uint = 2;
pub const __NEWLIB_MINOR__: libc::c_uint = 1;
pub const __RAND_MAX: libc::c_uint = 2147483647;
pub const ___int8_t_defined: libc::c_uint = 1;
pub const ___int16_t_defined: libc::c_uint = 1;
pub const ___int32_t_defined: libc::c_uint = 1;
pub const ___int64_t_defined: libc::c_uint = 1;
pub const _NULL: libc::c_uint = 0;
pub const _ATEXIT_SIZE: libc::c_uint = 32;
pub const _RAND48_SEED_0: libc::c_uint = 13070;
pub const _RAND48_SEED_1: libc::c_uint = 43981;
pub const _RAND48_SEED_2: libc::c_uint = 4660;
pub const _RAND48_MULT_0: libc::c_uint = 58989;
pub const _RAND48_MULT_1: libc::c_uint = 57068;
pub const _RAND48_MULT_2: libc::c_uint = 5;
pub const _RAND48_ADD: libc::c_uint = 11;
pub const _REENT_EMERGENCY_SIZE: libc::c_uint = 25;
pub const _REENT_ASCTIME_SIZE: libc::c_uint = 26;
pub const _REENT_SIGNAL_SIZE: libc::c_uint = 24;
pub const __GNUCLIKE_ASM: libc::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: libc::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: libc::c_uint = 1;
pub const __GNUCLIKE___SECTION: libc::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: libc::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: libc::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: libc::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: libc::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: libc::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: libc::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: libc::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: libc::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: libc::c_uint = 1;
pub const __POSIX_VISIBLE: libc::c_uint = 200809;
pub const __XSI_VISIBLE: libc::c_uint = 700;
pub const __BSD_VISIBLE: libc::c_uint = 1;
pub const __ISO_C_VISIBLE: libc::c_uint = 2011;
pub const __GNU_VISIBLE: libc::c_uint = 1;
pub const EXIT_FAILURE: libc::c_uint = 1;
pub const EXIT_SUCCESS: libc::c_uint = 0;
pub const RAND_MAX: libc::c_uint = 2147483647;
pub const __have_longlong64: libc::c_uint = 1;
pub const __int8_t_defined: libc::c_uint = 1;
pub const __int_least8_t_defined: libc::c_uint = 1;
pub const __int16_t_defined: libc::c_uint = 1;
pub const __int_least16_t_defined: libc::c_uint = 1;
pub const __int32_t_defined: libc::c_uint = 1;
pub const __int_least32_t_defined: libc::c_uint = 1;
pub const __int64_t_defined: libc::c_uint = 1;
pub const __int_least64_t_defined: libc::c_uint = 1;
pub const __int_fast8_t_defined: libc::c_uint = 1;
pub const __int_fast16_t_defined: libc::c_uint = 1;
pub const __int_fast32_t_defined: libc::c_uint = 1;
pub const __int_fast64_t_defined: libc::c_uint = 1;
pub const WINT_MIN: libc::c_uint = 0;
pub const __bool_true_false_are_defined: libc::c_uint = 1;
pub const NBBY: libc::c_uint = 8;
pub const FD_SETSIZE: libc::c_uint = 64;
pub const __SLBF: libc::c_uint = 1;
pub const __SNBF: libc::c_uint = 2;
pub const __SRD: libc::c_uint = 4;
pub const __SWR: libc::c_uint = 8;
pub const __SRW: libc::c_uint = 16;
pub const __SEOF: libc::c_uint = 32;
pub const __SERR: libc::c_uint = 64;
pub const __SMBF: libc::c_uint = 128;
pub const __SAPP: libc::c_uint = 256;
pub const __SSTR: libc::c_uint = 512;
pub const __SOPT: libc::c_uint = 1024;
pub const __SNPT: libc::c_uint = 2048;
pub const __SOFF: libc::c_uint = 4096;
pub const __SORD: libc::c_uint = 8192;
pub const __SL64: libc::c_uint = 32768;
pub const __SNLK: libc::c_uint = 1;
pub const __SWID: libc::c_uint = 8192;
pub const _IOFBF: libc::c_uint = 0;
pub const _IOLBF: libc::c_uint = 1;
pub const _IONBF: libc::c_uint = 2;
pub const EOF: libc::c_int = -1;
pub const BUFSIZ: libc::c_uint = 1024;
pub const FOPEN_MAX: libc::c_uint = 20;
pub const FILENAME_MAX: libc::c_uint = 1024;
pub const L_tmpnam: libc::c_uint = 1024;
pub const SEEK_SET: libc::c_uint = 0;
pub const SEEK_CUR: libc::c_uint = 1;
pub const SEEK_END: libc::c_uint = 2;
pub const TMP_MAX: libc::c_uint = 26;
pub const _M_LN2: f64 = 0.6931471805599453;
pub const FP_NAN: libc::c_uint = 0;
pub const FP_INFINITE: libc::c_uint = 1;
pub const FP_ZERO: libc::c_uint = 2;
pub const FP_SUBNORMAL: libc::c_uint = 3;
pub const FP_NORMAL: libc::c_uint = 4;
pub const MATH_ERRNO: libc::c_uint = 1;
pub const MATH_ERREXCEPT: libc::c_uint = 2;
pub const math_errhandling: libc::c_uint = 1;
pub const B0: libc::c_uint = 0;
pub const B00: libc::c_uint = 0;
pub const B000: libc::c_uint = 0;
pub const B0000: libc::c_uint = 0;
pub const B00000: libc::c_uint = 0;
pub const B000000: libc::c_uint = 0;
pub const B0000000: libc::c_uint = 0;
pub const B00000000: libc::c_uint = 0;
pub const B1: libc::c_uint = 1;
pub const B01: libc::c_uint = 1;
pub const B001: libc::c_uint = 1;
pub const B0001: libc::c_uint = 1;
pub const B00001: libc::c_uint = 1;
pub const B000001: libc::c_uint = 1;
pub const B0000001: libc::c_uint = 1;
pub const B00000001: libc::c_uint = 1;
pub const B10: libc::c_uint = 2;
pub const B010: libc::c_uint = 2;
pub const B0010: libc::c_uint = 2;
pub const B00010: libc::c_uint = 2;
pub const B000010: libc::c_uint = 2;
pub const B0000010: libc::c_uint = 2;
pub const B00000010: libc::c_uint = 2;
pub const B11: libc::c_uint = 3;
pub const B011: libc::c_uint = 3;
pub const B0011: libc::c_uint = 3;
pub const B00011: libc::c_uint = 3;
pub const B000011: libc::c_uint = 3;
pub const B0000011: libc::c_uint = 3;
pub const B00000011: libc::c_uint = 3;
pub const B100: libc::c_uint = 4;
pub const B0100: libc::c_uint = 4;
pub const B00100: libc::c_uint = 4;
pub const B000100: libc::c_uint = 4;
pub const B0000100: libc::c_uint = 4;
pub const B00000100: libc::c_uint = 4;
pub const B101: libc::c_uint = 5;
pub const B0101: libc::c_uint = 5;
pub const B00101: libc::c_uint = 5;
pub const B000101: libc::c_uint = 5;
pub const B0000101: libc::c_uint = 5;
pub const B00000101: libc::c_uint = 5;
pub const B110: libc::c_uint = 6;
pub const B0110: libc::c_uint = 6;
pub const B00110: libc::c_uint = 6;
pub const B000110: libc::c_uint = 6;
pub const B0000110: libc::c_uint = 6;
pub const B00000110: libc::c_uint = 6;
pub const B111: libc::c_uint = 7;
pub const B0111: libc::c_uint = 7;
pub const B00111: libc::c_uint = 7;
pub const B000111: libc::c_uint = 7;
pub const B0000111: libc::c_uint = 7;
pub const B00000111: libc::c_uint = 7;
pub const B1000: libc::c_uint = 8;
pub const B01000: libc::c_uint = 8;
pub const B001000: libc::c_uint = 8;
pub const B0001000: libc::c_uint = 8;
pub const B00001000: libc::c_uint = 8;
pub const B1001: libc::c_uint = 9;
pub const B01001: libc::c_uint = 9;
pub const B001001: libc::c_uint = 9;
pub const B0001001: libc::c_uint = 9;
pub const B00001001: libc::c_uint = 9;
pub const B1010: libc::c_uint = 10;
pub const B01010: libc::c_uint = 10;
pub const B001010: libc::c_uint = 10;
pub const B0001010: libc::c_uint = 10;
pub const B00001010: libc::c_uint = 10;
pub const B1011: libc::c_uint = 11;
pub const B01011: libc::c_uint = 11;
pub const B001011: libc::c_uint = 11;
pub const B0001011: libc::c_uint = 11;
pub const B00001011: libc::c_uint = 11;
pub const B1100: libc::c_uint = 12;
pub const B01100: libc::c_uint = 12;
pub const B001100: libc::c_uint = 12;
pub const B0001100: libc::c_uint = 12;
pub const B00001100: libc::c_uint = 12;
pub const B1101: libc::c_uint = 13;
pub const B01101: libc::c_uint = 13;
pub const B001101: libc::c_uint = 13;
pub const B0001101: libc::c_uint = 13;
pub const B00001101: libc::c_uint = 13;
pub const B1110: libc::c_uint = 14;
pub const B01110: libc::c_uint = 14;
pub const B001110: libc::c_uint = 14;
pub const B0001110: libc::c_uint = 14;
pub const B00001110: libc::c_uint = 14;
pub const B1111: libc::c_uint = 15;
pub const B01111: libc::c_uint = 15;
pub const B001111: libc::c_uint = 15;
pub const B0001111: libc::c_uint = 15;
pub const B00001111: libc::c_uint = 15;
pub const B10000: libc::c_uint = 16;
pub const B010000: libc::c_uint = 16;
pub const B0010000: libc::c_uint = 16;
pub const B00010000: libc::c_uint = 16;
pub const B10001: libc::c_uint = 17;
pub const B010001: libc::c_uint = 17;
pub const B0010001: libc::c_uint = 17;
pub const B00010001: libc::c_uint = 17;
pub const B10010: libc::c_uint = 18;
pub const B010010: libc::c_uint = 18;
pub const B0010010: libc::c_uint = 18;
pub const B00010010: libc::c_uint = 18;
pub const B10011: libc::c_uint = 19;
pub const B010011: libc::c_uint = 19;
pub const B0010011: libc::c_uint = 19;
pub const B00010011: libc::c_uint = 19;
pub const B10100: libc::c_uint = 20;
pub const B010100: libc::c_uint = 20;
pub const B0010100: libc::c_uint = 20;
pub const B00010100: libc::c_uint = 20;
pub const B10101: libc::c_uint = 21;
pub const B010101: libc::c_uint = 21;
pub const B0010101: libc::c_uint = 21;
pub const B00010101: libc::c_uint = 21;
pub const B10110: libc::c_uint = 22;
pub const B010110: libc::c_uint = 22;
pub const B0010110: libc::c_uint = 22;
pub const B00010110: libc::c_uint = 22;
pub const B10111: libc::c_uint = 23;
pub const B010111: libc::c_uint = 23;
pub const B0010111: libc::c_uint = 23;
pub const B00010111: libc::c_uint = 23;
pub const B11000: libc::c_uint = 24;
pub const B011000: libc::c_uint = 24;
pub const B0011000: libc::c_uint = 24;
pub const B00011000: libc::c_uint = 24;
pub const B11001: libc::c_uint = 25;
pub const B011001: libc::c_uint = 25;
pub const B0011001: libc::c_uint = 25;
pub const B00011001: libc::c_uint = 25;
pub const B11010: libc::c_uint = 26;
pub const B011010: libc::c_uint = 26;
pub const B0011010: libc::c_uint = 26;
pub const B00011010: libc::c_uint = 26;
pub const B11011: libc::c_uint = 27;
pub const B011011: libc::c_uint = 27;
pub const B0011011: libc::c_uint = 27;
pub const B00011011: libc::c_uint = 27;
pub const B11100: libc::c_uint = 28;
pub const B011100: libc::c_uint = 28;
pub const B0011100: libc::c_uint = 28;
pub const B00011100: libc::c_uint = 28;
pub const B11101: libc::c_uint = 29;
pub const B011101: libc::c_uint = 29;
pub const B0011101: libc::c_uint = 29;
pub const B00011101: libc::c_uint = 29;
pub const B11110: libc::c_uint = 30;
pub const B011110: libc::c_uint = 30;
pub const B0011110: libc::c_uint = 30;
pub const B00011110: libc::c_uint = 30;
pub const B11111: libc::c_uint = 31;
pub const B011111: libc::c_uint = 31;
pub const B0011111: libc::c_uint = 31;
pub const B00011111: libc::c_uint = 31;
pub const B100000: libc::c_uint = 32;
pub const B0100000: libc::c_uint = 32;
pub const B00100000: libc::c_uint = 32;
pub const B100001: libc::c_uint = 33;
pub const B0100001: libc::c_uint = 33;
pub const B00100001: libc::c_uint = 33;
pub const B100010: libc::c_uint = 34;
pub const B0100010: libc::c_uint = 34;
pub const B00100010: libc::c_uint = 34;
pub const B100011: libc::c_uint = 35;
pub const B0100011: libc::c_uint = 35;
pub const B00100011: libc::c_uint = 35;
pub const B100100: libc::c_uint = 36;
pub const B0100100: libc::c_uint = 36;
pub const B00100100: libc::c_uint = 36;
pub const B100101: libc::c_uint = 37;
pub const B0100101: libc::c_uint = 37;
pub const B00100101: libc::c_uint = 37;
pub const B100110: libc::c_uint = 38;
pub const B0100110: libc::c_uint = 38;
pub const B00100110: libc::c_uint = 38;
pub const B100111: libc::c_uint = 39;
pub const B0100111: libc::c_uint = 39;
pub const B00100111: libc::c_uint = 39;
pub const B101000: libc::c_uint = 40;
pub const B0101000: libc::c_uint = 40;
pub const B00101000: libc::c_uint = 40;
pub const B101001: libc::c_uint = 41;
pub const B0101001: libc::c_uint = 41;
pub const B00101001: libc::c_uint = 41;
pub const B101010: libc::c_uint = 42;
pub const B0101010: libc::c_uint = 42;
pub const B00101010: libc::c_uint = 42;
pub const B101011: libc::c_uint = 43;
pub const B0101011: libc::c_uint = 43;
pub const B00101011: libc::c_uint = 43;
pub const B101100: libc::c_uint = 44;
pub const B0101100: libc::c_uint = 44;
pub const B00101100: libc::c_uint = 44;
pub const B101101: libc::c_uint = 45;
pub const B0101101: libc::c_uint = 45;
pub const B00101101: libc::c_uint = 45;
pub const B101110: libc::c_uint = 46;
pub const B0101110: libc::c_uint = 46;
pub const B00101110: libc::c_uint = 46;
pub const B101111: libc::c_uint = 47;
pub const B0101111: libc::c_uint = 47;
pub const B00101111: libc::c_uint = 47;
pub const B110000: libc::c_uint = 48;
pub const B0110000: libc::c_uint = 48;
pub const B00110000: libc::c_uint = 48;
pub const B110001: libc::c_uint = 49;
pub const B0110001: libc::c_uint = 49;
pub const B00110001: libc::c_uint = 49;
pub const B110010: libc::c_uint = 50;
pub const B0110010: libc::c_uint = 50;
pub const B00110010: libc::c_uint = 50;
pub const B110011: libc::c_uint = 51;
pub const B0110011: libc::c_uint = 51;
pub const B00110011: libc::c_uint = 51;
pub const B110100: libc::c_uint = 52;
pub const B0110100: libc::c_uint = 52;
pub const B00110100: libc::c_uint = 52;
pub const B110101: libc::c_uint = 53;
pub const B0110101: libc::c_uint = 53;
pub const B00110101: libc::c_uint = 53;
pub const B110110: libc::c_uint = 54;
pub const B0110110: libc::c_uint = 54;
pub const B00110110: libc::c_uint = 54;
pub const B110111: libc::c_uint = 55;
pub const B0110111: libc::c_uint = 55;
pub const B00110111: libc::c_uint = 55;
pub const B111000: libc::c_uint = 56;
pub const B0111000: libc::c_uint = 56;
pub const B00111000: libc::c_uint = 56;
pub const B111001: libc::c_uint = 57;
pub const B0111001: libc::c_uint = 57;
pub const B00111001: libc::c_uint = 57;
pub const B111010: libc::c_uint = 58;
pub const B0111010: libc::c_uint = 58;
pub const B00111010: libc::c_uint = 58;
pub const B111011: libc::c_uint = 59;
pub const B0111011: libc::c_uint = 59;
pub const B00111011: libc::c_uint = 59;
pub const B111100: libc::c_uint = 60;
pub const B0111100: libc::c_uint = 60;
pub const B00111100: libc::c_uint = 60;
pub const B111101: libc::c_uint = 61;
pub const B0111101: libc::c_uint = 61;
pub const B00111101: libc::c_uint = 61;
pub const B111110: libc::c_uint = 62;
pub const B0111110: libc::c_uint = 62;
pub const B00111110: libc::c_uint = 62;
pub const B111111: libc::c_uint = 63;
pub const B0111111: libc::c_uint = 63;
pub const B00111111: libc::c_uint = 63;
pub const B1000000: libc::c_uint = 64;
pub const B01000000: libc::c_uint = 64;
pub const B1000001: libc::c_uint = 65;
pub const B01000001: libc::c_uint = 65;
pub const B1000010: libc::c_uint = 66;
pub const B01000010: libc::c_uint = 66;
pub const B1000011: libc::c_uint = 67;
pub const B01000011: libc::c_uint = 67;
pub const B1000100: libc::c_uint = 68;
pub const B01000100: libc::c_uint = 68;
pub const B1000101: libc::c_uint = 69;
pub const B01000101: libc::c_uint = 69;
pub const B1000110: libc::c_uint = 70;
pub const B01000110: libc::c_uint = 70;
pub const B1000111: libc::c_uint = 71;
pub const B01000111: libc::c_uint = 71;
pub const B1001000: libc::c_uint = 72;
pub const B01001000: libc::c_uint = 72;
pub const B1001001: libc::c_uint = 73;
pub const B01001001: libc::c_uint = 73;
pub const B1001010: libc::c_uint = 74;
pub const B01001010: libc::c_uint = 74;
pub const B1001011: libc::c_uint = 75;
pub const B01001011: libc::c_uint = 75;
pub const B1001100: libc::c_uint = 76;
pub const B01001100: libc::c_uint = 76;
pub const B1001101: libc::c_uint = 77;
pub const B01001101: libc::c_uint = 77;
pub const B1001110: libc::c_uint = 78;
pub const B01001110: libc::c_uint = 78;
pub const B1001111: libc::c_uint = 79;
pub const B01001111: libc::c_uint = 79;
pub const B1010000: libc::c_uint = 80;
pub const B01010000: libc::c_uint = 80;
pub const B1010001: libc::c_uint = 81;
pub const B01010001: libc::c_uint = 81;
pub const B1010010: libc::c_uint = 82;
pub const B01010010: libc::c_uint = 82;
pub const B1010011: libc::c_uint = 83;
pub const B01010011: libc::c_uint = 83;
pub const B1010100: libc::c_uint = 84;
pub const B01010100: libc::c_uint = 84;
pub const B1010101: libc::c_uint = 85;
pub const B01010101: libc::c_uint = 85;
pub const B1010110: libc::c_uint = 86;
pub const B01010110: libc::c_uint = 86;
pub const B1010111: libc::c_uint = 87;
pub const B01010111: libc::c_uint = 87;
pub const B1011000: libc::c_uint = 88;
pub const B01011000: libc::c_uint = 88;
pub const B1011001: libc::c_uint = 89;
pub const B01011001: libc::c_uint = 89;
pub const B1011010: libc::c_uint = 90;
pub const B01011010: libc::c_uint = 90;
pub const B1011011: libc::c_uint = 91;
pub const B01011011: libc::c_uint = 91;
pub const B1011100: libc::c_uint = 92;
pub const B01011100: libc::c_uint = 92;
pub const B1011101: libc::c_uint = 93;
pub const B01011101: libc::c_uint = 93;
pub const B1011110: libc::c_uint = 94;
pub const B01011110: libc::c_uint = 94;
pub const B1011111: libc::c_uint = 95;
pub const B01011111: libc::c_uint = 95;
pub const B1100000: libc::c_uint = 96;
pub const B01100000: libc::c_uint = 96;
pub const B1100001: libc::c_uint = 97;
pub const B01100001: libc::c_uint = 97;
pub const B1100010: libc::c_uint = 98;
pub const B01100010: libc::c_uint = 98;
pub const B1100011: libc::c_uint = 99;
pub const B01100011: libc::c_uint = 99;
pub const B1100100: libc::c_uint = 100;
pub const B01100100: libc::c_uint = 100;
pub const B1100101: libc::c_uint = 101;
pub const B01100101: libc::c_uint = 101;
pub const B1100110: libc::c_uint = 102;
pub const B01100110: libc::c_uint = 102;
pub const B1100111: libc::c_uint = 103;
pub const B01100111: libc::c_uint = 103;
pub const B1101000: libc::c_uint = 104;
pub const B01101000: libc::c_uint = 104;
pub const B1101001: libc::c_uint = 105;
pub const B01101001: libc::c_uint = 105;
pub const B1101010: libc::c_uint = 106;
pub const B01101010: libc::c_uint = 106;
pub const B1101011: libc::c_uint = 107;
pub const B01101011: libc::c_uint = 107;
pub const B1101100: libc::c_uint = 108;
pub const B01101100: libc::c_uint = 108;
pub const B1101101: libc::c_uint = 109;
pub const B01101101: libc::c_uint = 109;
pub const B1101110: libc::c_uint = 110;
pub const B01101110: libc::c_uint = 110;
pub const B1101111: libc::c_uint = 111;
pub const B01101111: libc::c_uint = 111;
pub const B1110000: libc::c_uint = 112;
pub const B01110000: libc::c_uint = 112;
pub const B1110001: libc::c_uint = 113;
pub const B01110001: libc::c_uint = 113;
pub const B1110010: libc::c_uint = 114;
pub const B01110010: libc::c_uint = 114;
pub const B1110011: libc::c_uint = 115;
pub const B01110011: libc::c_uint = 115;
pub const B1110100: libc::c_uint = 116;
pub const B01110100: libc::c_uint = 116;
pub const B1110101: libc::c_uint = 117;
pub const B01110101: libc::c_uint = 117;
pub const B1110110: libc::c_uint = 118;
pub const B01110110: libc::c_uint = 118;
pub const B1110111: libc::c_uint = 119;
pub const B01110111: libc::c_uint = 119;
pub const B1111000: libc::c_uint = 120;
pub const B01111000: libc::c_uint = 120;
pub const B1111001: libc::c_uint = 121;
pub const B01111001: libc::c_uint = 121;
pub const B1111010: libc::c_uint = 122;
pub const B01111010: libc::c_uint = 122;
pub const B1111011: libc::c_uint = 123;
pub const B01111011: libc::c_uint = 123;
pub const B1111100: libc::c_uint = 124;
pub const B01111100: libc::c_uint = 124;
pub const B1111101: libc::c_uint = 125;
pub const B01111101: libc::c_uint = 125;
pub const B1111110: libc::c_uint = 126;
pub const B01111110: libc::c_uint = 126;
pub const B1111111: libc::c_uint = 127;
pub const B01111111: libc::c_uint = 127;
pub const B10000000: libc::c_uint = 128;
pub const B10000001: libc::c_uint = 129;
pub const B10000010: libc::c_uint = 130;
pub const B10000011: libc::c_uint = 131;
pub const B10000100: libc::c_uint = 132;
pub const B10000101: libc::c_uint = 133;
pub const B10000110: libc::c_uint = 134;
pub const B10000111: libc::c_uint = 135;
pub const B10001000: libc::c_uint = 136;
pub const B10001001: libc::c_uint = 137;
pub const B10001010: libc::c_uint = 138;
pub const B10001011: libc::c_uint = 139;
pub const B10001100: libc::c_uint = 140;
pub const B10001101: libc::c_uint = 141;
pub const B10001110: libc::c_uint = 142;
pub const B10001111: libc::c_uint = 143;
pub const B10010000: libc::c_uint = 144;
pub const B10010001: libc::c_uint = 145;
pub const B10010010: libc::c_uint = 146;
pub const B10010011: libc::c_uint = 147;
pub const B10010100: libc::c_uint = 148;
pub const B10010101: libc::c_uint = 149;
pub const B10010110: libc::c_uint = 150;
pub const B10010111: libc::c_uint = 151;
pub const B10011000: libc::c_uint = 152;
pub const B10011001: libc::c_uint = 153;
pub const B10011010: libc::c_uint = 154;
pub const B10011011: libc::c_uint = 155;
pub const B10011100: libc::c_uint = 156;
pub const B10011101: libc::c_uint = 157;
pub const B10011110: libc::c_uint = 158;
pub const B10011111: libc::c_uint = 159;
pub const B10100000: libc::c_uint = 160;
pub const B10100001: libc::c_uint = 161;
pub const B10100010: libc::c_uint = 162;
pub const B10100011: libc::c_uint = 163;
pub const B10100100: libc::c_uint = 164;
pub const B10100101: libc::c_uint = 165;
pub const B10100110: libc::c_uint = 166;
pub const B10100111: libc::c_uint = 167;
pub const B10101000: libc::c_uint = 168;
pub const B10101001: libc::c_uint = 169;
pub const B10101010: libc::c_uint = 170;
pub const B10101011: libc::c_uint = 171;
pub const B10101100: libc::c_uint = 172;
pub const B10101101: libc::c_uint = 173;
pub const B10101110: libc::c_uint = 174;
pub const B10101111: libc::c_uint = 175;
pub const B10110000: libc::c_uint = 176;
pub const B10110001: libc::c_uint = 177;
pub const B10110010: libc::c_uint = 178;
pub const B10110011: libc::c_uint = 179;
pub const B10110100: libc::c_uint = 180;
pub const B10110101: libc::c_uint = 181;
pub const B10110110: libc::c_uint = 182;
pub const B10110111: libc::c_uint = 183;
pub const B10111000: libc::c_uint = 184;
pub const B10111001: libc::c_uint = 185;
pub const B10111010: libc::c_uint = 186;
pub const B10111011: libc::c_uint = 187;
pub const B10111100: libc::c_uint = 188;
pub const B10111101: libc::c_uint = 189;
pub const B10111110: libc::c_uint = 190;
pub const B10111111: libc::c_uint = 191;
pub const B11000000: libc::c_uint = 192;
pub const B11000001: libc::c_uint = 193;
pub const B11000010: libc::c_uint = 194;
pub const B11000011: libc::c_uint = 195;
pub const B11000100: libc::c_uint = 196;
pub const B11000101: libc::c_uint = 197;
pub const B11000110: libc::c_uint = 198;
pub const B11000111: libc::c_uint = 199;
pub const B11001000: libc::c_uint = 200;
pub const B11001001: libc::c_uint = 201;
pub const B11001010: libc::c_uint = 202;
pub const B11001011: libc::c_uint = 203;
pub const B11001100: libc::c_uint = 204;
pub const B11001101: libc::c_uint = 205;
pub const B11001110: libc::c_uint = 206;
pub const B11001111: libc::c_uint = 207;
pub const B11010000: libc::c_uint = 208;
pub const B11010001: libc::c_uint = 209;
pub const B11010010: libc::c_uint = 210;
pub const B11010011: libc::c_uint = 211;
pub const B11010100: libc::c_uint = 212;
pub const B11010101: libc::c_uint = 213;
pub const B11010110: libc::c_uint = 214;
pub const B11010111: libc::c_uint = 215;
pub const B11011000: libc::c_uint = 216;
pub const B11011001: libc::c_uint = 217;
pub const B11011010: libc::c_uint = 218;
pub const B11011011: libc::c_uint = 219;
pub const B11011100: libc::c_uint = 220;
pub const B11011101: libc::c_uint = 221;
pub const B11011110: libc::c_uint = 222;
pub const B11011111: libc::c_uint = 223;
pub const B11100000: libc::c_uint = 224;
pub const B11100001: libc::c_uint = 225;
pub const B11100010: libc::c_uint = 226;
pub const B11100011: libc::c_uint = 227;
pub const B11100100: libc::c_uint = 228;
pub const B11100101: libc::c_uint = 229;
pub const B11100110: libc::c_uint = 230;
pub const B11100111: libc::c_uint = 231;
pub const B11101000: libc::c_uint = 232;
pub const B11101001: libc::c_uint = 233;
pub const B11101010: libc::c_uint = 234;
pub const B11101011: libc::c_uint = 235;
pub const B11101100: libc::c_uint = 236;
pub const B11101101: libc::c_uint = 237;
pub const B11101110: libc::c_uint = 238;
pub const B11101111: libc::c_uint = 239;
pub const B11110000: libc::c_uint = 240;
pub const B11110001: libc::c_uint = 241;
pub const B11110010: libc::c_uint = 242;
pub const B11110011: libc::c_uint = 243;
pub const B11110100: libc::c_uint = 244;
pub const B11110101: libc::c_uint = 245;
pub const B11110110: libc::c_uint = 246;
pub const B11110111: libc::c_uint = 247;
pub const B11111000: libc::c_uint = 248;
pub const B11111001: libc::c_uint = 249;
pub const B11111010: libc::c_uint = 250;
pub const B11111011: libc::c_uint = 251;
pub const B11111100: libc::c_uint = 252;
pub const B11111101: libc::c_uint = 253;
pub const B11111110: libc::c_uint = 254;
pub const B11111111: libc::c_uint = 255;
pub const ESP8266_CLOCK: libc::c_uint = 80000000;
pub const GPCWE: libc::c_uint = 10;
pub const GPCI: libc::c_uint = 7;
pub const GPCD: libc::c_uint = 2;
pub const GPCS: libc::c_uint = 0;
pub const GPFSOE: libc::c_uint = 0;
pub const GPFSS: libc::c_uint = 1;
pub const GPFSPD: libc::c_uint = 2;
pub const GPFSPU: libc::c_uint = 3;
pub const GPFFS0: libc::c_uint = 4;
pub const GPFFS1: libc::c_uint = 5;
pub const GPFPD: libc::c_uint = 6;
pub const GPFPU: libc::c_uint = 7;
pub const GPFFS2: libc::c_uint = 8;
pub const GP16FFS0: libc::c_uint = 0;
pub const GP16FFS1: libc::c_uint = 1;
pub const GP16FPD: libc::c_uint = 3;
pub const GP16FSPD: libc::c_uint = 5;
pub const GP16FFS2: libc::c_uint = 6;
pub const TEIE1: libc::c_uint = 2;
pub const TCIS: libc::c_uint = 8;
pub const TCTE: libc::c_uint = 7;
pub const TCAR: libc::c_uint = 6;
pub const TCPD: libc::c_uint = 2;
pub const TCIT: libc::c_uint = 0;
pub const IOSWAPU: libc::c_uint = 0;
pub const IOSWAPS: libc::c_uint = 1;
pub const IOSWAPU0: libc::c_uint = 2;
pub const IOSWAPU1: libc::c_uint = 3;
pub const IOSWAPHS: libc::c_uint = 5;
pub const IOSWAP2HS: libc::c_uint = 6;
pub const IOSWAP2CS: libc::c_uint = 7;
pub const UIS0: libc::c_uint = 0;
pub const UIS1: libc::c_uint = 2;
pub const UITO: libc::c_uint = 8;
pub const UIBD: libc::c_uint = 7;
pub const UICTS: libc::c_uint = 6;
pub const UIDSR: libc::c_uint = 5;
pub const UIOF: libc::c_uint = 4;
pub const UIFR: libc::c_uint = 3;
pub const UIPE: libc::c_uint = 2;
pub const UIFE: libc::c_uint = 1;
pub const UIFF: libc::c_uint = 0;
pub const USTX: libc::c_uint = 31;
pub const USRTS: libc::c_uint = 30;
pub const USDTR: libc::c_uint = 39;
pub const USTXC: libc::c_uint = 16;
pub const USRXD: libc::c_uint = 15;
pub const USCTS: libc::c_uint = 14;
pub const USDSR: libc::c_uint = 13;
pub const USRXC: libc::c_uint = 0;
pub const UCDTRI: libc::c_uint = 24;
pub const UCRTSI: libc::c_uint = 23;
pub const UCTXI: libc::c_uint = 22;
pub const UCDSRI: libc::c_uint = 21;
pub const UCCTSI: libc::c_uint = 20;
pub const UCRXI: libc::c_uint = 19;
pub const UCTXRST: libc::c_uint = 18;
pub const UCRXRST: libc::c_uint = 17;
pub const UCTXHFE: libc::c_uint = 15;
pub const UCLBE: libc::c_uint = 14;
pub const UCBRK: libc::c_uint = 8;
pub const UCSWDTR: libc::c_uint = 7;
pub const UCSWRTS: libc::c_uint = 6;
pub const UCSBN: libc::c_uint = 4;
pub const UCBN: libc::c_uint = 2;
pub const UCPAE: libc::c_uint = 1;
pub const UCPA: libc::c_uint = 0;
pub const UCTOE: libc::c_uint = 31;
pub const UCTOT: libc::c_uint = 24;
pub const UCRXHFE: libc::c_uint = 23;
pub const UCRXHFT: libc::c_uint = 16;
pub const UCFET: libc::c_uint = 8;
pub const UCFFT: libc::c_uint = 0;
pub const SPI_BUSY: libc::c_uint = 9;
pub const SPII0: libc::c_uint = 4;
pub const SPII1: libc::c_uint = 7;
pub const SPII2: libc::c_uint = 9;
pub const SPICMDREAD: libc::c_uint = 2147483648;
pub const SPICMDWREN: libc::c_uint = 1073741824;
pub const SPICMDWRDI: libc::c_uint = 536870912;
pub const SPICMDRDID: libc::c_uint = 268435456;
pub const SPICMDRDSR: libc::c_uint = 134217728;
pub const SPICMDWRSR: libc::c_uint = 67108864;
pub const SPICMDPP: libc::c_uint = 33554432;
pub const SPICMDSE: libc::c_uint = 16777216;
pub const SPICMDBE: libc::c_uint = 8388608;
pub const SPICMDCE: libc::c_uint = 4194304;
pub const SPICMDDP: libc::c_uint = 2097152;
pub const SPICMDRES: libc::c_uint = 1048576;
pub const SPICMDHPM: libc::c_uint = 524288;
pub const SPICMDUSR: libc::c_uint = 262144;
pub const SPIBUSY: libc::c_uint = 262144;
pub const SPICWBO: libc::c_uint = 67108864;
pub const SPICRBO: libc::c_uint = 33554432;
pub const SPICQIO: libc::c_uint = 16777216;
pub const SPICDIO: libc::c_uint = 8388608;
pub const SPIC2BSE: libc::c_uint = 4194304;
pub const SPICWPR: libc::c_uint = 2097152;
pub const SPICQOUT: libc::c_uint = 1048576;
pub const SPICSHARE: libc::c_uint = 524288;
pub const SPICHOLD: libc::c_uint = 262144;
pub const SPICAHB: libc::c_uint = 131072;
pub const SPICSSTAAI: libc::c_uint = 65536;
pub const SPICRESANDRES: libc::c_uint = 32768;
pub const SPICDOUT: libc::c_uint = 16384;
pub const SPICFASTRD: libc::c_uint = 8192;
pub const SPIC1TCSH: libc::c_uint = 15;
pub const SPIC1TCSH_S: libc::c_uint = 28;
pub const SPIC1TRES: libc::c_uint = 4095;
pub const SPIC1TRES_S: libc::c_uint = 16;
pub const SPIC1BTL: libc::c_uint = 65535;
pub const SPIC1BTL_S: libc::c_uint = 0;
pub const SPIRSEXT: libc::c_uint = 255;
pub const SPIRSEXT_S: libc::c_uint = 24;
pub const SPIRSWB: libc::c_uint = 255;
pub const SPIRSWB_S: libc::c_uint = 16;
pub const SPIRSSP: libc::c_uint = 128;
pub const SPIRSTBP: libc::c_uint = 32;
pub const SPIRSBP2: libc::c_uint = 16;
pub const SPIRSBP1: libc::c_uint = 8;
pub const SPIRSBP0: libc::c_uint = 4;
pub const SPIRSWRE: libc::c_uint = 2;
pub const SPIRSBUSY: libc::c_uint = 1;
pub const SPIC2CSDN: libc::c_uint = 15;
pub const SPIC2CSDN_S: libc::c_uint = 28;
pub const SPIC2CSDM: libc::c_uint = 3;
pub const SPIC2CSDM_S: libc::c_uint = 26;
pub const SPIC2MOSIDN: libc::c_uint = 7;
pub const SPIC2MOSIDN_S: libc::c_uint = 23;
pub const SPIC2MOSIDM: libc::c_uint = 3;
pub const SPIC2MOSIDM_S: libc::c_uint = 21;
pub const SPIC2MISODN: libc::c_uint = 7;
pub const SPIC2MISODN_S: libc::c_uint = 18;
pub const SPIC2MISODM: libc::c_uint = 3;
pub const SPIC2MISODM_S: libc::c_uint = 16;
pub const SPIC2CKOHM: libc::c_uint = 15;
pub const SPIC2CKOHM_S: libc::c_uint = 12;
pub const SPIC2CKOLM: libc::c_uint = 15;
pub const SPIC2CKOLM_S: libc::c_uint = 8;
pub const SPIC2HT: libc::c_uint = 15;
pub const SPIC2HT_S: libc::c_uint = 4;
pub const SPIC2ST: libc::c_uint = 15;
pub const SPIC2ST_S: libc::c_uint = 0;
pub const SPICLK_EQU_SYSCLK: libc::c_uint = 2147483648;
pub const SPICLKDIVPRE: libc::c_uint = 8191;
pub const SPICLKDIVPRE_S: libc::c_uint = 18;
pub const SPICLKCN: libc::c_uint = 63;
pub const SPICLKCN_S: libc::c_uint = 12;
pub const SPICLKCH: libc::c_uint = 63;
pub const SPICLKCH_S: libc::c_uint = 6;
pub const SPICLKCL: libc::c_uint = 63;
pub const SPICLKCL_S: libc::c_uint = 0;
pub const SPIUCOMMAND: libc::c_uint = 2147483648;
pub const SPIUADDR: libc::c_uint = 1073741824;
pub const SPIUDUMMY: libc::c_uint = 536870912;
pub const SPIUMISO: libc::c_uint = 268435456;
pub const SPIUMOSI: libc::c_uint = 134217728;
pub const SPIUDUMMYIDLE: libc::c_uint = 67108864;
pub const SPIUMOSIH: libc::c_uint = 33554432;
pub const SPIUMISOH: libc::c_uint = 16777216;
pub const SPIUPREPHOLD: libc::c_uint = 8388608;
pub const SPIUCMDHOLD: libc::c_uint = 4194304;
pub const SPIUADDRHOLD: libc::c_uint = 2097152;
pub const SPIUDUMMYHOLD: libc::c_uint = 1048576;
pub const SPIUMISOHOLD: libc::c_uint = 524288;
pub const SPIUMOSIHOLD: libc::c_uint = 262144;
pub const SPIUHOLDPOL: libc::c_uint = 131072;
pub const SPIUSIO: libc::c_uint = 65536;
pub const SPIUFWQIO: libc::c_uint = 32768;
pub const SPIUFWDIO: libc::c_uint = 16384;
pub const SPIUFWQUAD: libc::c_uint = 8192;
pub const SPIUFWDUAL: libc::c_uint = 4096;
pub const SPIUWRBYO: libc::c_uint = 2048;
pub const SPIURDBYO: libc::c_uint = 1024;
pub const SPIUAHBEM: libc::c_uint = 3;
pub const SPIUAHBEM_S: libc::c_uint = 8;
pub const SPIUSME: libc::c_uint = 128;
pub const SPIUSSE: libc::c_uint = 64;
pub const SPIUCSSETUP: libc::c_uint = 32;
pub const SPIUCSHOLD: libc::c_uint = 16;
pub const SPIUAHBUCMD: libc::c_uint = 8;
pub const SPIUAHBUCMD4B: libc::c_uint = 2;
pub const SPIUDUPLEX: libc::c_uint = 1;
pub const SPILCOMMAND: libc::c_uint = 28;
pub const SPILADDR: libc::c_uint = 26;
pub const SPILDUMMY: libc::c_uint = 0;
pub const SPILMISO: libc::c_uint = 8;
pub const SPILMOSI: libc::c_uint = 17;
pub const SPIMCOMMAND: libc::c_uint = 15;
pub const SPIMADDR: libc::c_uint = 63;
pub const SPIMDUMMY: libc::c_uint = 255;
pub const SPIMMISO: libc::c_uint = 511;
pub const SPIMMOSI: libc::c_uint = 511;
pub const SPISSRES: libc::c_uint = 2147483648;
pub const SPISE: libc::c_uint = 1073741824;
pub const SPISBE: libc::c_uint = 536870912;
pub const SPISSE: libc::c_uint = 268435456;
pub const SPISCD: libc::c_uint = 134217728;
pub const SPISTRCNT: libc::c_uint = 15;
pub const SPISTRCNT_S: libc::c_uint = 23;
pub const SPISSLS: libc::c_uint = 7;
pub const SPISSLS_S: libc::c_uint = 20;
pub const SPISSLC: libc::c_uint = 7;
pub const SPISSLC_S: libc::c_uint = 17;
pub const SPISCSIM: libc::c_uint = 3;
pub const SPIDCSIM_S: libc::c_uint = 10;
pub const SPISTRIE: libc::c_uint = 512;
pub const SPISWSIE: libc::c_uint = 256;
pub const SPISRSIE: libc::c_uint = 128;
pub const SPISWBIE: libc::c_uint = 64;
pub const SPISRBIE: libc::c_uint = 32;
pub const SPISTRIS: libc::c_uint = 16;
pub const SPISWSIS: libc::c_uint = 8;
pub const SPISRSIS: libc::c_uint = 4;
pub const SPISWBIS: libc::c_uint = 2;
pub const SPISRBIS: libc::c_uint = 1;
pub const SPIS1LSTA: libc::c_uint = 27;
pub const SPIS1FE: libc::c_uint = 67108864;
pub const SPIS1RSTA: libc::c_uint = 33554432;
pub const SPIS1LBUF: libc::c_uint = 16;
pub const SPIS1LRBA: libc::c_uint = 10;
pub const SPIS1LWBA: libc::c_uint = 4;
pub const SPIS1WSDE: libc::c_uint = 8;
pub const SPIS1RSDE: libc::c_uint = 4;
pub const SPIS1WBDE: libc::c_uint = 2;
pub const SPIS1RBDE: libc::c_uint = 1;
pub const SPIS2WBDL: libc::c_uint = 255;
pub const SPIS2WBDL_S: libc::c_uint = 24;
pub const SPIS2RBDL: libc::c_uint = 255;
pub const SPIS2RBDL_S: libc::c_uint = 16;
pub const SPIS2WSDL: libc::c_uint = 255;
pub const SPIS2WSDL_S: libc::c_uint = 8;
pub const SPIS2RSDL: libc::c_uint = 255;
pub const SPIS2RSDL_S: libc::c_uint = 0;
pub const SPIS3WSCV: libc::c_uint = 255;
pub const SPIS3WSCV_S: libc::c_uint = 24;
pub const SPIS3RSCV: libc::c_uint = 255;
pub const SPIS3RSCV_S: libc::c_uint = 16;
pub const SPIS3WBCV: libc::c_uint = 255;
pub const SPIS3WBCV_S: libc::c_uint = 8;
pub const SPIS3RBCV: libc::c_uint = 255;
pub const SPIS3RBCV_S: libc::c_uint = 0;
pub const SPIE0TPPEN: libc::c_uint = 2147483648;
pub const SPIE0TPPS: libc::c_uint = 15;
pub const SPIE0TPPS_S: libc::c_uint = 16;
pub const SPIE0TPPT: libc::c_uint = 4095;
pub const SPIE0TPPT_S: libc::c_uint = 0;
pub const SPIE1TEREN: libc::c_uint = 2147483648;
pub const SPIE1TERS: libc::c_uint = 15;
pub const SPIE1TERS_S: libc::c_uint = 16;
pub const SPIE1TERT: libc::c_uint = 4095;
pub const SPIE1TERT_S: libc::c_uint = 0;
pub const SPIE2ST: libc::c_uint = 7;
pub const SPIE2ST_S: libc::c_uint = 0;
pub const SPIE2IHEN: libc::c_uint = 3;
pub const SPIE2IHEN_S: libc::c_uint = 0;
pub const SPIPCS2DIS: libc::c_uint = 4;
pub const SPIPCS1DIS: libc::c_uint = 2;
pub const SPIPCS0DIS: libc::c_uint = 1;
pub const SLCMM: libc::c_uint = 3;
pub const SLCM: libc::c_uint = 12;
pub const SLCDTBE: libc::c_uint = 512;
pub const SLCDBE: libc::c_uint = 256;
pub const SLCRXNRC: libc::c_uint = 128;
pub const SLCRXAW: libc::c_uint = 64;
pub const SLCRXLT: libc::c_uint = 32;
pub const SLCTXLT: libc::c_uint = 16;
pub const SLCAR: libc::c_uint = 8;
pub const SLCAFR: libc::c_uint = 4;
pub const SLCRXLR: libc::c_uint = 2;
pub const SLCTXLR: libc::c_uint = 1;
pub const SLCITXDE: libc::c_uint = 2097152;
pub const SLCIRXDER: libc::c_uint = 1048576;
pub const SLCITXDER: libc::c_uint = 524288;
pub const SLCITH: libc::c_uint = 262144;
pub const SLCIRXEOF: libc::c_uint = 131072;
pub const SLCIRXD: libc::c_uint = 65536;
pub const SLCITXEOF: libc::c_uint = 32768;
pub const SLCITXD: libc::c_uint = 16384;
pub const SLCIT0: libc::c_uint = 8192;
pub const SLCIT1: libc::c_uint = 4096;
pub const SLCITXO: libc::c_uint = 2048;
pub const SLCIRXU: libc::c_uint = 1024;
pub const SLCITXS: libc::c_uint = 512;
pub const SLCIRXS: libc::c_uint = 256;
pub const SLCIFH7: libc::c_uint = 128;
pub const SLCIFH6: libc::c_uint = 64;
pub const SLCIFH5: libc::c_uint = 32;
pub const SLCIFH4: libc::c_uint = 16;
pub const SLCIFH3: libc::c_uint = 8;
pub const SLCIFH2: libc::c_uint = 4;
pub const SLCIFH1: libc::c_uint = 2;
pub const SLCIFH0: libc::c_uint = 1;
pub const SLCRXE: libc::c_uint = 2;
pub const SLCRXF: libc::c_uint = 1;
pub const SLCTXE: libc::c_uint = 2;
pub const SLCTXF: libc::c_uint = 1;
pub const SLCRXFP: libc::c_uint = 65536;
pub const SLCRXWDM: libc::c_uint = 511;
pub const SLCRXWD: libc::c_uint = 0;
pub const SLCTXFP: libc::c_uint = 65536;
pub const SLCTXRDM: libc::c_uint = 2047;
pub const SLCTXRD: libc::c_uint = 0;
pub const SLCRXLP: libc::c_uint = 2147483648;
pub const SLCRXLRS: libc::c_uint = 1073741824;
pub const SLCRXLS: libc::c_uint = 536870912;
pub const SLCRXLE: libc::c_uint = 268435456;
pub const SLCRXLAM: libc::c_uint = 65535;
pub const SLCRXLA: libc::c_uint = 0;
pub const SLCTXLP: libc::c_uint = 2147483648;
pub const SLCTXLRS: libc::c_uint = 1073741824;
pub const SLCTXLS: libc::c_uint = 536870912;
pub const SLCTXLE: libc::c_uint = 268435456;
pub const SLCTXLAM: libc::c_uint = 65535;
pub const SLCTXLA: libc::c_uint = 0;
pub const SLCTM: libc::c_uint = 4095;
pub const SLCTT: libc::c_uint = 16;
pub const SLCTIM: libc::c_uint = 16384;
pub const SLCTI: libc::c_uint = 8192;
pub const SLCTW: libc::c_uint = 4096;
pub const SLCTDM: libc::c_uint = 4095;
pub const SLCTD: libc::c_uint = 0;
pub const SLCBFMEM: libc::c_uint = 15;
pub const SLCBFME: libc::c_uint = 8;
pub const SLCBTEEM: libc::c_uint = 63;
pub const SLCBTEE: libc::c_uint = 0;
pub const SLCATAM: libc::c_uint = 3;
pub const SLCATA: libc::c_uint = 4;
pub const SLCATMM: libc::c_uint = 7;
pub const SLCATM: libc::c_uint = 0;
pub const SLCSBM: libc::c_uint = 7;
pub const SLCSB: libc::c_uint = 12;
pub const SLCSW: libc::c_uint = 256;
pub const SLCSFM: libc::c_uint = 15;
pub const SLCSF: libc::c_uint = 4;
pub const SLCSCM: libc::c_uint = 7;
pub const SLCSC: libc::c_uint = 0;
pub const SLCBRXFE: libc::c_uint = 1048576;
pub const SLCBRXEM: libc::c_uint = 524288;
pub const SLCBRXFM: libc::c_uint = 262144;
pub const SLCBINR: libc::c_uint = 131072;
pub const SLCBTNR: libc::c_uint = 65536;
pub const SLCBPICM: libc::c_uint = 65535;
pub const SLCBPIC: libc::c_uint = 0;
pub const i2c_bbpll: libc::c_uint = 103;
pub const i2c_bbpll_hostid: libc::c_uint = 4;
pub const i2c_bbpll_en_audio_clock_out: libc::c_uint = 4;
pub const i2c_bbpll_en_audio_clock_out_msb: libc::c_uint = 7;
pub const i2c_bbpll_en_audio_clock_out_lsb: libc::c_uint = 7;
pub const I2SBASEFREQ: libc::c_uint = 12000000;
pub const I2SBDM: libc::c_uint = 63;
pub const I2SBD: libc::c_uint = 22;
pub const I2SCDM: libc::c_uint = 63;
pub const I2SCD: libc::c_uint = 16;
pub const I2SBMM: libc::c_uint = 15;
pub const I2SBM: libc::c_uint = 12;
pub const I2SRMS: libc::c_uint = 2048;
pub const I2STMS: libc::c_uint = 1024;
pub const I2SRXS: libc::c_uint = 512;
pub const I2STXS: libc::c_uint = 256;
pub const I2SMR: libc::c_uint = 128;
pub const I2SRF: libc::c_uint = 64;
pub const I2SRSM: libc::c_uint = 32;
pub const I2STSM: libc::c_uint = 16;
pub const I2SRXFR: libc::c_uint = 8;
pub const I2STXFR: libc::c_uint = 4;
pub const I2SRXR: libc::c_uint = 2;
pub const I2STXR: libc::c_uint = 1;
pub const I2SRST: libc::c_uint = 15;
pub const I2SITXRE: libc::c_uint = 32;
pub const I2SITXWF: libc::c_uint = 16;
pub const I2SIRXRE: libc::c_uint = 8;
pub const I2SIRXWF: libc::c_uint = 4;
pub const I2SITXPD: libc::c_uint = 2;
pub const I2SIRXTD: libc::c_uint = 1;
pub const I2STBII: libc::c_uint = 4194304;
pub const I2SRDS: libc::c_uint = 2097152;
pub const I2STDS: libc::c_uint = 1048576;
pub const I2SRBODM: libc::c_uint = 3;
pub const I2SRBOD: libc::c_uint = 18;
pub const I2SRWODM: libc::c_uint = 3;
pub const I2SRWOD: libc::c_uint = 16;
pub const I2STSODM: libc::c_uint = 3;
pub const I2STSOD: libc::c_uint = 14;
pub const I2STWODM: libc::c_uint = 3;
pub const I2STWOD: libc::c_uint = 12;
pub const I2STBODM: libc::c_uint = 3;
pub const I2STBOD: libc::c_uint = 10;
pub const I2SRSIDM: libc::c_uint = 3;
pub const I2SRSID: libc::c_uint = 8;
pub const I2SRWIDM: libc::c_uint = 3;
pub const I2SRWID: libc::c_uint = 6;
pub const I2SRBIDM: libc::c_uint = 3;
pub const I2SRBID: libc::c_uint = 4;
pub const I2STWIDM: libc::c_uint = 3;
pub const I2STWID: libc::c_uint = 2;
pub const I2STBIDM: libc::c_uint = 3;
pub const I2STBID: libc::c_uint = 0;
pub const I2SRXFMM: libc::c_uint = 7;
pub const I2SRXFM: libc::c_uint = 16;
pub const I2STXFMM: libc::c_uint = 7;
pub const I2STXFM: libc::c_uint = 13;
pub const I2SDE: libc::c_uint = 4096;
pub const I2STXDNM: libc::c_uint = 63;
pub const I2STXDN: libc::c_uint = 6;
pub const I2SRXDNM: libc::c_uint = 63;
pub const I2SRXDN: libc::c_uint = 0;
pub const I2SRXCMM: libc::c_uint = 3;
pub const I2SRXCM: libc::c_uint = 3;
pub const I2STXCMM: libc::c_uint = 7;
pub const I2STXCM: libc::c_uint = 0;
pub const I2C_OK: libc::c_uint = 0;
pub const I2C_SCL_HELD_LOW: libc::c_uint = 1;
pub const I2C_SCL_HELD_LOW_AFTER_READ: libc::c_uint = 2;
pub const I2C_SDA_HELD_LOW: libc::c_uint = 3;
pub const I2C_SDA_HELD_LOW_AFTER_INIT: libc::c_uint = 4;
pub const HIGH: libc::c_uint = 1;
pub const LOW: libc::c_uint = 0;
pub const PWMRANGE: libc::c_uint = 1023;
pub const INPUT: libc::c_uint = 0;
pub const INPUT_PULLUP: libc::c_uint = 2;
pub const INPUT_PULLDOWN_16: libc::c_uint = 4;
pub const OUTPUT: libc::c_uint = 1;
pub const OUTPUT_OPEN_DRAIN: libc::c_uint = 3;
pub const WAKEUP_PULLUP: libc::c_uint = 5;
pub const WAKEUP_PULLDOWN: libc::c_uint = 7;
pub const SPECIAL: libc::c_uint = 248;
pub const FUNCTION_0: libc::c_uint = 8;
pub const FUNCTION_1: libc::c_uint = 24;
pub const FUNCTION_2: libc::c_uint = 40;
pub const FUNCTION_3: libc::c_uint = 56;
pub const FUNCTION_4: libc::c_uint = 72;
pub const PI: f64 = 3.141592653589793;
pub const HALF_PI: f64 = 1.5707963267948966;
pub const TWO_PI: f64 = 6.283185307179586;
pub const DEG_TO_RAD: f64 = 0.017453292519943295;
pub const RAD_TO_DEG: f64 = 57.29577951308232;
pub const EULER: f64 = 2.718281828459045;
pub const SERIAL: libc::c_uint = 0;
pub const DISPLAY: libc::c_uint = 1;
pub const LSBFIRST: libc::c_uint = 0;
pub const MSBFIRST: libc::c_uint = 1;
pub const RISING: libc::c_uint = 1;
pub const FALLING: libc::c_uint = 2;
pub const CHANGE: libc::c_uint = 3;
pub const ONLOW: libc::c_uint = 4;
pub const ONHIGH: libc::c_uint = 5;
pub const ONLOW_WE: libc::c_uint = 12;
pub const ONHIGH_WE: libc::c_uint = 13;
pub const DEFAULT: libc::c_uint = 1;
pub const EXTERNAL: libc::c_uint = 0;
pub const TIM_DIV1: libc::c_uint = 0;
pub const TIM_DIV16: libc::c_uint = 1;
pub const TIM_DIV265: libc::c_uint = 3;
pub const TIM_EDGE: libc::c_uint = 0;
pub const TIM_LEVEL: libc::c_uint = 1;
pub const TIM_SINGLE: libc::c_uint = 0;
pub const TIM_LOOP: libc::c_uint = 1;
pub const NOT_A_PIN: libc::c_int = -1;
pub const NOT_A_PORT: libc::c_int = -1;
pub const NOT_AN_INTERRUPT: libc::c_int = -1;
pub const NOT_ON_TIMER: libc::c_uint = 0;
pub const SIZE_IRRELEVANT: libc::c_uint = 2147483647;
pub const _U: libc::c_uint = 1;
pub const _L: libc::c_uint = 2;
pub const _N: libc::c_uint = 4;
pub const _S: libc::c_uint = 8;
pub const _P: libc::c_uint = 16;
pub const _C: libc::c_uint = 32;
pub const _X: libc::c_uint = 64;
pub const _B: libc::c_uint = 128;
pub const DEC: libc::c_uint = 10;
pub const HEX: libc::c_uint = 16;
pub const OCT: libc::c_uint = 8;
pub const BIN: libc::c_uint = 2;
pub const UART0: libc::c_uint = 0;
pub const UART1: libc::c_uint = 1;
pub const UART_NO: libc::c_int = -1;
pub const UART_FULL: libc::c_uint = 0;
pub const UART_RX_ONLY: libc::c_uint = 1;
pub const UART_TX_ONLY: libc::c_uint = 2;
pub const UART_TX_FIFO_SIZE: libc::c_uint = 128;
pub const FLASH_SECTOR_SIZE: libc::c_uint = 4096;
pub const FLASH_BLOCK_SIZE: libc::c_uint = 65536;
pub const APP_START_OFFSET: libc::c_uint = 4096;
pub const UPDATE_ERROR_OK: libc::c_uint = 0;
pub const UPDATE_ERROR_WRITE: libc::c_uint = 1;
pub const UPDATE_ERROR_ERASE: libc::c_uint = 2;
pub const UPDATE_ERROR_READ: libc::c_uint = 3;
pub const UPDATE_ERROR_SPACE: libc::c_uint = 4;
pub const UPDATE_ERROR_SIZE: libc::c_uint = 5;
pub const UPDATE_ERROR_STREAM: libc::c_uint = 6;
pub const UPDATE_ERROR_MD5: libc::c_uint = 7;
pub const UPDATE_ERROR_FLASH_CONFIG: libc::c_uint = 8;
pub const UPDATE_ERROR_NEW_FLASH_CONFIG: libc::c_uint = 9;
pub const UPDATE_ERROR_MAGIC_BYTE: libc::c_uint = 10;
pub const UPDATE_ERROR_BOOTSTRAP: libc::c_uint = 11;
pub const U_FLASH: libc::c_uint = 0;
pub const U_SPIFFS: libc::c_uint = 100;
pub const U_AUTH: libc::c_uint = 200;
pub const EXTERNAL_NUM_INTERRUPTS: libc::c_uint = 16;
pub const NUM_DIGITAL_PINS: libc::c_uint = 17;
pub const NUM_ANALOG_INPUTS: libc::c_uint = 1;
pub const PIN_SPI_SS: libc::c_uint = 15;
pub const PIN_SPI_MOSI: libc::c_uint = 13;
pub const PIN_SPI_MISO: libc::c_uint = 12;
pub const PIN_SPI_SCK: libc::c_uint = 14;
pub const PIN_A0: libc::c_uint = 17;
pub const PIN_WIRE_SDA: libc::c_uint = 4;
pub const PIN_WIRE_SCL: libc::c_uint = 5;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __max_align_ll: libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::core::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) . __max_align_ll as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __max_align_ll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) . __max_align_ld as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __max_align_ld ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __uint64_t = libc::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __intptr_t = libc::c_long;
pub type __uintptr_t = libc::c_ulong;
pub type _lock_t = libc::c_int;
pub type _LOCK_RECURSIVE_T = _lock_t;
pub type _LOCK_T = _lock_t;
extern "C" {
    pub fn _lock_init(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_init_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_try_acquire(lock: *mut _lock_t) -> libc::c_int;
}
extern "C" {
    pub fn _lock_try_acquire_recursive(lock: *mut _lock_t) -> libc::c_int;
}
extern "C" {
    pub fn _lock_release(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_release_recursive(lock: *mut _lock_t);
}
pub type _off_t = libc::c_long;
pub type __dev_t = libc::c_short;
pub type __uid_t = libc::c_ushort;
pub type __gid_t = libc::c_ushort;
pub type _off64_t = libc::c_longlong;
pub type _fpos_t = libc::c_long;
pub type _ssize_t = libc::c_long;
pub type wint_t = libc::c_uint;
#[repr(C)]
#[derive(Copy)]
pub struct _mbstate_t {
    pub __count: libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [libc::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<_mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( _mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<_mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _mbstate_t__bindgen_ty_1 ) ) . __wch as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb ) ));
}
impl Clone for _mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    assert_eq!(::core::mem::size_of::<_mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _mbstate_t ) ));
    assert_eq! (::core::mem::align_of::<_mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for _mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut libc::c_void;
pub type __ULong = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _reent {
    pub _errno: libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: libc::c_int,
    pub _emergency: *mut libc::c_char,
    pub __sdidinit: libc::c_int,
    pub _current_category: libc::c_int,
    pub _current_locale: *const libc::c_char,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut _reent)>,
    pub _gamma_signgam: libc::c_int,
    pub _cvtlen: libc::c_int,
    pub _cvtbuf: *mut libc::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut libc::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        libc::c_int)>,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub __sglue: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__reent() {
    assert_eq!(::core::mem::size_of::<_reent>() , 464usize , concat ! (
               "Size of: " , stringify ! ( _reent ) ));
    assert_eq! (::core::mem::align_of::<_reent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _reent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _errno as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _stdin as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _stdin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _stdout as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _stdout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _stderr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _stderr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _inc as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _inc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _emergency as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _emergency ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . __sdidinit as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( __sdidinit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _current_category as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _current_category ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _current_locale as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _current_locale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _mp as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _mp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . __cleanup as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( __cleanup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _gamma_signgam as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _gamma_signgam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _cvtlen as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _cvtlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _cvtbuf as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _cvtbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _r48 as * const _ as usize }
                , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _r48 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _localtime_buf as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _localtime_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _asctime_buf as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _asctime_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _sig_func as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _sig_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _atexit as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _atexit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _atexit0 as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _atexit0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . __sglue as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( __sglue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . __sf as * const _ as usize }
                , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( __sf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _misc as * const _ as usize
                } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _misc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _reent ) ) . _signal_buf as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( _reent ) , "::" ,
                stringify ! ( _signal_buf ) ));
}
impl Clone for _reent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: libc::c_int,
    pub _maxwds: libc::c_int,
    pub _sign: libc::c_int,
    pub _wds: libc::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    assert_eq!(::core::mem::size_of::<_Bigint>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _Bigint ) ));
    assert_eq! (::core::mem::align_of::<_Bigint>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _Bigint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _Bigint ) ) . _next as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _Bigint ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _Bigint ) ) . _k as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _Bigint ) , "::" ,
                stringify ! ( _k ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _Bigint ) ) . _maxwds as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _Bigint ) , "::" ,
                stringify ! ( _maxwds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _Bigint ) ) . _sign as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _Bigint ) , "::" ,
                stringify ! ( _sign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _Bigint ) ) . _wds as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _Bigint ) , "::" ,
                stringify ! ( _wds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _Bigint ) ) . _x as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _Bigint ) , "::" ,
                stringify ! ( _x ) ));
}
impl Clone for _Bigint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __tm {
    pub __tm_sec: libc::c_int,
    pub __tm_min: libc::c_int,
    pub __tm_hour: libc::c_int,
    pub __tm_mday: libc::c_int,
    pub __tm_mon: libc::c_int,
    pub __tm_year: libc::c_int,
    pub __tm_wday: libc::c_int,
    pub __tm_yday: libc::c_int,
    pub __tm_isdst: libc::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    assert_eq!(::core::mem::size_of::<__tm>() , 36usize , concat ! (
               "Size of: " , stringify ! ( __tm ) ));
    assert_eq! (::core::mem::align_of::<__tm>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __tm ) ) . __tm_sec as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __tm ) , "::" ,
                stringify ! ( __tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __tm ) ) . __tm_min as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __tm ) , "::" ,
                stringify ! ( __tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __tm ) ) . __tm_hour as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __tm ) , "::" ,
                stringify ! ( __tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __tm ) ) . __tm_mday as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __tm ) , "::" ,
                stringify ! ( __tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __tm ) ) . __tm_mon as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __tm ) , "::" ,
                stringify ! ( __tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __tm ) ) . __tm_year as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __tm ) , "::" ,
                stringify ! ( __tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __tm ) ) . __tm_wday as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __tm ) , "::" ,
                stringify ! ( __tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __tm ) ) . __tm_yday as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( __tm ) , "::" ,
                stringify ! ( __tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __tm ) ) . __tm_isdst as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __tm ) , "::" ,
                stringify ! ( __tm_isdst ) ));
}
impl Clone for __tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _on_exit_args {
    pub _fnargs: [*mut libc::c_void; 32usize],
    pub _dso_handle: [*mut libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    assert_eq!(::core::mem::size_of::<_on_exit_args>() , 520usize , concat ! (
               "Size of: " , stringify ! ( _on_exit_args ) ));
    assert_eq! (::core::mem::align_of::<_on_exit_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _on_exit_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _on_exit_args ) ) . _fnargs as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _on_exit_args ) , "::"
                , stringify ! ( _fnargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _on_exit_args ) ) . _dso_handle as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( _on_exit_args ) , "::"
                , stringify ! ( _dso_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _on_exit_args ) ) . _fntypes as * const _
                as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( _on_exit_args ) , "::"
                , stringify ! ( _fntypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _on_exit_args ) ) . _is_cxa as * const _
                as usize } , 516usize , concat ! (
                "Alignment of field: " , stringify ! ( _on_exit_args ) , "::"
                , stringify ! ( _is_cxa ) ));
}
impl Clone for _on_exit_args {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    assert_eq!(::core::mem::size_of::<_atexit>() , 280usize , concat ! (
               "Size of: " , stringify ! ( _atexit ) ));
    assert_eq! (::core::mem::align_of::<_atexit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _atexit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _atexit ) ) . _next as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _atexit ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _atexit ) ) . _ind as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _atexit ) , "::" ,
                stringify ! ( _ind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _atexit ) ) . _fns as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _atexit ) , "::" ,
                stringify ! ( _fns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _atexit ) ) . _on_exit_args_ptr as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( _atexit ) , "::" ,
                stringify ! ( _on_exit_args_ptr ) ));
}
impl Clone for _atexit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut libc::c_uchar,
    pub _size: libc::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::core::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::core::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sFILE_fake {
    pub _p: *mut libc::c_uchar,
    pub _r: libc::c_int,
    pub _w: libc::c_int,
    pub _flags: libc::c_short,
    pub _file: libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: libc::c_int,
    pub _data: *mut _reent,
}
#[test]
fn bindgen_test_layout___sFILE_fake() {
    assert_eq!(::core::mem::size_of::<__sFILE_fake>() , 56usize , concat ! (
               "Size of: " , stringify ! ( __sFILE_fake ) ));
    assert_eq! (::core::mem::align_of::<__sFILE_fake>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE_fake ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE_fake ) ) . _p as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE_fake ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE_fake ) ) . _r as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE_fake ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE_fake ) ) . _w as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE_fake ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE_fake ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE_fake ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE_fake ) ) . _file as * const _ as
                usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE_fake ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE_fake ) ) . _bf as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE_fake ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE_fake ) ) . _lbfsize as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE_fake ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE_fake ) ) . _data as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE_fake ) , "::" ,
                stringify ! ( _data ) ));
}
impl Clone for __sFILE_fake {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy)]
pub struct __sFILE {
    pub _p: *mut libc::c_uchar,
    pub _r: libc::c_int,
    pub _w: libc::c_int,
    pub _flags: libc::c_short,
    pub _file: libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: libc::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut libc::c_void,
    pub _read: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
                                                           arg2:
                                                               *mut libc::c_void,
                                                           arg3:
                                                               *mut libc::c_char,
                                                           arg4: libc::c_int)
                                          -> libc::c_int>,
    pub _write: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
                                                            arg2:
                                                                *mut libc::c_void,
                                                            arg3:
                                                                *const libc::c_char,
                                                            arg4: libc::c_int)
                                           -> libc::c_int>,
    pub _seek: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
                                                           arg2:
                                                               *mut libc::c_void,
                                                           arg3: _fpos_t,
                                                           arg4: libc::c_int)
                                          -> _fpos_t>,
    pub _close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
                                                            arg2:
                                                                *mut libc::c_void)
                                           -> libc::c_int>,
    pub _ub: __sbuf,
    pub _up: *mut libc::c_uchar,
    pub _ur: libc::c_int,
    pub _ubuf: [libc::c_uchar; 3usize],
    pub _nbuf: [libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: libc::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: libc::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::core::mem::size_of::<__sFILE>() , 176usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::core::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _data as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _up as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _up ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 127usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lock as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _mbstate as * const _ as
                usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _mbstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags2 as * const _ as
                usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags2 ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: libc::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    assert_eq!(::core::mem::size_of::<_glue>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _glue ) ));
    assert_eq! (::core::mem::align_of::<_glue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _glue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _glue ) ) . _next as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _glue ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _glue ) ) . _niobs as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _glue ) , "::" ,
                stringify ! ( _niobs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _glue ) ) . _iobs as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _glue ) , "::" ,
                stringify ! ( _iobs ) ));
}
impl Clone for _glue {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _rand48 {
    pub _seed: [libc::c_ushort; 3usize],
    pub _mult: [libc::c_ushort; 3usize],
    pub _add: libc::c_ushort,
    pub _rand_next: libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout__rand48() {
    assert_eq!(::core::mem::size_of::<_rand48>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _rand48 ) ));
    assert_eq! (::core::mem::align_of::<_rand48>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _rand48 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _rand48 ) ) . _seed as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _rand48 ) , "::" ,
                stringify ! ( _seed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _rand48 ) ) . _mult as * const _ as usize
                } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _rand48 ) , "::" ,
                stringify ! ( _mult ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _rand48 ) ) . _add as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _rand48 ) , "::" ,
                stringify ! ( _add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _rand48 ) ) . _rand_next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _rand48 ) , "::" ,
                stringify ! ( _rand_next ) ));
}
impl Clone for _rand48 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[test]
fn bindgen_test_layout__mprec() {
    assert_eq!(::core::mem::size_of::<_mprec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _mprec ) ));
    assert_eq! (::core::mem::align_of::<_mprec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _mprec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _mprec ) ) . _result as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _mprec ) , "::" ,
                stringify ! ( _result ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _mprec ) ) . _result_k as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _mprec ) , "::" ,
                stringify ! ( _result_k ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _mprec ) ) . _p5s as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _mprec ) , "::" ,
                stringify ! ( _p5s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _mprec ) ) . _freelist as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _mprec ) , "::" ,
                stringify ! ( _freelist ) ));
}
impl Clone for _mprec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _misc_reent {
    pub _strtok_last: *mut libc::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [libc::c_char; 8usize],
    pub _getdate_err: libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[test]
fn bindgen_test_layout__misc_reent() {
    assert_eq!(::core::mem::size_of::<_misc_reent>() , 88usize , concat ! (
               "Size of: " , stringify ! ( _misc_reent ) ));
    assert_eq! (::core::mem::align_of::<_misc_reent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _misc_reent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _strtok_last as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _strtok_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _mblen_state as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _mblen_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _wctomb_state as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _wctomb_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _mbtowc_state as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _mbtowc_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _l64a_buf as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _l64a_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _getdate_err as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _getdate_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _mbrlen_state as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _mbrlen_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _mbrtowc_state as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _mbrtowc_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _mbsrtowcs_state as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _mbsrtowcs_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _wcrtomb_state as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _wcrtomb_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _misc_reent ) ) . _wcsrtombs_state as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( _misc_reent ) , "::" ,
                stringify ! ( _wcsrtombs_state ) ));
}
impl Clone for _misc_reent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "__sf_fake_stdin"]
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    #[link_name = "__sf_fake_stdout"]
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    #[link_name = "__sf_fake_stderr"]
    pub static __sf_fake_stderr: __sFILE_fake;
}
extern "C" {
    #[link_name = "_impure_ptr"]
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    #[link_name = "_global_impure_ptr"]
    pub static _global_impure_ptr: *const _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::core::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::core::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::core::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::core::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::core::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::core::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
pub type __compar_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *const libc::c_void,
                                                arg2: *const libc::c_void)
                               -> libc::c_int>;
extern "C" {
    pub fn __locale_mb_cur_max() -> libc::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>)
     -> libc::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const libc::c_char)
     -> libc::c_long;
}
extern "C" {
    pub fn bsearch(__key: *const libc::c_void, __base: *const libc::c_void,
                   __nmemb: usize, __size: usize, _compar: __compar_fn_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn div(__numer: libc::c_int, __denom: libc::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: libc::c_int);
}
extern "C" {
    pub fn free(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn getenv(__string: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn _getenv_r(arg1: *mut _reent, __string: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _findenv(arg1: *const libc::c_char, arg2: *mut libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _findenv_r(arg1: *mut _reent, arg2: *const libc::c_char,
                      arg3: *mut libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn labs(arg1: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn ldiv(__numer: libc::c_long, __denom: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const libc::c_char, arg2: usize) -> libc::c_int;
}
extern "C" {
    pub fn _mblen_r(arg1: *mut _reent, arg2: *const libc::c_char, arg3: usize,
                    arg4: *mut _mbstate_t) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(arg1: *mut u16, arg2: *const libc::c_char, arg3: usize)
     -> libc::c_int;
}
extern "C" {
    pub fn _mbtowc_r(arg1: *mut _reent, arg2: *mut u16,
                     arg3: *const libc::c_char, arg4: usize,
                     arg5: *mut _mbstate_t) -> libc::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut libc::c_char, arg2: u16) -> libc::c_int;
}
extern "C" {
    pub fn _wctomb_r(arg1: *mut _reent, arg2: *mut libc::c_char, arg3: u16,
                     arg4: *mut _mbstate_t) -> libc::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut u16, arg2: *const libc::c_char, arg3: usize)
     -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(arg1: *mut _reent, arg2: *mut u16,
                       arg3: *const libc::c_char, arg4: usize,
                       arg5: *mut _mbstate_t) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut libc::c_char, arg2: *const u16, arg3: usize)
     -> usize;
}
extern "C" {
    pub fn _wcstombs_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                       arg3: *const u16, arg4: usize, arg5: *mut _mbstate_t)
     -> usize;
}
extern "C" {
    pub fn qsort(__base: *mut libc::c_void, __nmemb: usize, __size: usize,
                 _compar: __compar_fn_t);
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn realloc(__r: *mut libc::c_void, __size: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn srand(__seed: libc::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const libc::c_char, __end_PTR: *mut *mut libc::c_char)
     -> f64;
}
extern "C" {
    pub fn _strtod_r(arg1: *mut _reent, __n: *const libc::c_char,
                     __end_PTR: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const libc::c_char, __end_PTR: *mut *mut libc::c_char)
     -> f32;
}
extern "C" {
    pub fn strtol(__n: *const libc::c_char, __end_PTR: *mut *mut libc::c_char,
                  __base: libc::c_int) -> libc::c_long;
}
extern "C" {
    pub fn _strtol_r(arg1: *mut _reent, __n: *const libc::c_char,
                     __end_PTR: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_long;
}
extern "C" {
    pub fn strtoul(__n: *const libc::c_char,
                   __end_PTR: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(arg1: *mut _reent, __n: *const libc::c_char,
                      __end_PTR: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_ulong;
}
extern "C" {
    pub fn system(__string: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn _Exit(__status: libc::c_int);
}
extern "C" {
    pub fn __itoa(arg1: libc::c_int, arg2: *mut libc::c_char,
                  arg3: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn __utoa(arg1: libc::c_uint, arg2: *mut libc::c_char,
                  arg3: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn atoll(__nptr: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: libc::c_longlong, __denom: libc::c_longlong)
     -> lldiv_t;
}
extern "C" {
    pub fn strtoll(__n: *const libc::c_char,
                   __end_PTR: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_longlong;
}
extern "C" {
    pub fn strtoull(__n: *const libc::c_char,
                    __end_PTR: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_ulonglong;
}
extern "C" {
    pub fn _dtoa_r(arg1: *mut _reent, arg2: f64, arg3: libc::c_int,
                   arg4: libc::c_int, arg5: *mut libc::c_int,
                   arg6: *mut libc::c_int, arg7: *mut *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut libc::c_void);
}
extern "C" {
    pub fn _realloc_r(arg1: *mut _reent, arg2: *mut libc::c_void, arg3: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut libc::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn __eprintf(arg1: *const libc::c_char, arg2: *const libc::c_char,
                     arg3: libc::c_uint, arg4: *const libc::c_char);
}
extern "C" {
    pub fn qsort_r(__base: *mut libc::c_void, __nmemb: usize, __size: usize,
                   _compar:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const libc::c_void,
                                                                   arg2:
                                                                       *const libc::c_void,
                                                                   arg3:
                                                                       *mut libc::c_void)
                                                  -> libc::c_int>,
                   __thunk: *mut libc::c_void);
}
extern "C" {
    pub fn strtold(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char)
     -> f64;
}
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = libc::c_schar;
pub type uint_fast8_t = libc::c_uchar;
pub type int_fast16_t = libc::c_short;
pub type uint_fast16_t = libc::c_ushort;
pub type int_fast32_t = libc::c_int;
pub type uint_fast32_t = libc::c_uint;
pub type int_fast64_t = libc::c_long;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = libc::c_long;
pub type uintmax_t = libc::c_ulong;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type __off_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __loff_t = libc::c_longlong;
pub type u_char = libc::c_uchar;
pub type u_short = libc::c_ushort;
pub type u_int = libc::c_uint;
pub type u_long = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type ulong = libc::c_ulong;
pub type clock_t = libc::c_ulong;
pub type time_t = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: libc::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::core::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::core::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::core::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::core::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type daddr_t = libc::c_long;
pub type caddr_t = *mut libc::c_char;
pub type ino_t = libc::c_ushort;
pub type off_t = _off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = libc::c_int;
pub type key_t = libc::c_long;
pub type mode_t = libc::c_uint;
pub type nlink_t = libc::c_ushort;
pub type fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 1usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    assert_eq!(::core::mem::size_of::<_types_fd_set>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _types_fd_set ) ));
    assert_eq! (::core::mem::align_of::<_types_fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _types_fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _types_fd_set ) ) . fds_bits as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _types_fd_set ) , "::"
                , stringify ! ( fds_bits ) ));
}
impl Clone for _types_fd_set {
    fn clone(&self) -> Self { *self }
}
pub type clockid_t = libc::c_ulong;
pub type timer_t = libc::c_ulong;
pub type useconds_t = libc::c_ulong;
pub type suseconds_t = libc::c_long;
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tempnam(arg1: *const libc::c_char, arg2: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn freopen(arg1: *const libc::c_char, arg2: *const libc::c_char,
                   arg3: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut libc::c_char);
}
extern "C" {
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut libc::c_char,
                   arg3: libc::c_int, arg4: usize) -> libc::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn printf(arg1: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const libc::c_char, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const libc::c_char,
                    arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const libc::c_char, arg2: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut libc::c_char, arg2: *const libc::c_char,
                    arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut libc::c_char, arg2: libc::c_int, arg3: *mut FILE)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn fputc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const libc::c_char, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar() -> libc::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn putc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn puts(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ungetc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread(arg1: *mut libc::c_void, _size: usize, _n: usize,
                 arg2: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(arg1: *const libc::c_void, _size: usize, _n: usize,
                  arg2: *mut FILE) -> usize;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: libc::c_long, arg3: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn perror(arg1: *const libc::c_char);
}
extern "C" {
    pub fn fopen(_name: *const libc::c_char, _type: *const libc::c_char)
     -> *mut FILE;
}
extern "C" {
    pub fn sprintf(arg1: *mut libc::c_char, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn remove(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rename(arg1: *const libc::c_char, arg2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn fcloseall() -> libc::c_int;
}
extern "C" {
    pub fn asiprintf(arg1: *mut *mut libc::c_char,
                     arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn asniprintf(arg1: *mut libc::c_char, arg2: *mut usize,
                      arg3: *const libc::c_char, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn asnprintf(arg1: *mut libc::c_char, arg2: *mut usize,
                     arg3: *const libc::c_char, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut libc::c_char,
                    arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn diprintf(arg1: libc::c_int, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn siprintf(arg1: *mut libc::c_char, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn siscanf(arg1: *const libc::c_char, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn snprintf(arg1: *mut libc::c_char, arg2: usize,
                    arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sniprintf(arg1: *mut libc::c_char, arg2: usize,
                     arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vasiprintf(arg1: *mut *mut libc::c_char, arg2: *const libc::c_char,
                      arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vasniprintf(arg1: *mut libc::c_char, arg2: *mut usize,
                       arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn vasnprintf(arg1: *mut libc::c_char, arg2: *mut usize,
                      arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn vasprintf(arg1: *mut *mut libc::c_char, arg2: *const libc::c_char,
                     arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vdiprintf(arg1: libc::c_int, arg2: *const libc::c_char,
                     arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vfiprintf(arg1: *mut FILE, arg2: *const libc::c_char,
                     arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vfiscanf(arg1: *mut FILE, arg2: *const libc::c_char,
                    arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vfscanf(arg1: *mut FILE, arg2: *const libc::c_char,
                   arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const libc::c_char, arg2: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const libc::c_char, arg2: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const libc::c_char, arg2: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn vsiprintf(arg1: *mut libc::c_char, arg2: *const libc::c_char,
                     arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsiscanf(arg1: *const libc::c_char, arg2: *const libc::c_char,
                    arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsniprintf(arg1: *mut libc::c_char, arg2: usize,
                      arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn vsnprintf(arg1: *mut libc::c_char, arg2: usize,
                     arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const libc::c_char, arg2: *const libc::c_char,
                   arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn _asiprintf_r(arg1: *mut _reent, arg2: *mut *mut libc::c_char,
                        arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _asniprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                         arg3: *mut usize, arg4: *const libc::c_char, ...)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _asnprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                        arg3: *mut usize, arg4: *const libc::c_char, ...)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _asprintf_r(arg1: *mut _reent, arg2: *mut *mut libc::c_char,
                       arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _diprintf_r(arg1: *mut _reent, arg2: libc::c_int,
                       arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _dprintf_r(arg1: *mut _reent, arg2: libc::c_int,
                      arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> libc::c_int;
}
extern "C" {
    pub fn _fdopen_r(arg1: *mut _reent, arg2: libc::c_int,
                     arg3: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE)
     -> libc::c_int;
}
extern "C" {
    pub fn _fgets_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                    arg3: libc::c_int, arg4: *mut FILE) -> *mut libc::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                             arg3: libc::c_int, arg4: *mut FILE)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t)
     -> libc::c_int;
}
extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t)
     -> libc::c_int;
}
extern "C" {
    pub fn _fiprintf_r(arg1: *mut _reent, arg2: *mut FILE,
                       arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _fiscanf_r(arg1: *mut _reent, arg2: *mut FILE,
                      arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _fmemopen_r(arg1: *mut _reent, arg2: *mut libc::c_void,
                       arg3: usize, arg4: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(arg1: *mut _reent, arg2: *const libc::c_char,
                    arg3: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(arg1: *mut _reent, arg2: *const libc::c_char,
                      arg3: *const libc::c_char, arg4: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(arg1: *mut _reent, arg2: *mut FILE,
                      arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn _fputc_r(arg1: *mut _reent, arg2: libc::c_int, arg3: *mut FILE)
     -> libc::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(arg1: *mut _reent, arg2: libc::c_int,
                             arg3: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn _fputs_r(arg1: *mut _reent, arg2: *const libc::c_char,
                    arg3: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(arg1: *mut _reent, arg2: *const libc::c_char,
                             arg3: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn _fread_r(arg1: *mut _reent, arg2: *mut libc::c_void, _size: usize,
                    _n: usize, arg3: *mut FILE) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(arg1: *mut _reent, arg2: *mut libc::c_void,
                             _size: usize, _n: usize, arg3: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn _fscanf_r(arg1: *mut _reent, arg2: *mut FILE,
                     arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _fseek_r(arg1: *mut _reent, arg2: *mut FILE, arg3: libc::c_long,
                    arg4: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _fseeko_r(arg1: *mut _reent, arg2: *mut FILE, arg3: _off_t,
                     arg4: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(arg1: *mut _reent, arg2: *const libc::c_void,
                     _size: usize, _n: usize, arg3: *mut FILE) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(arg1: *mut _reent, arg2: *const libc::c_void,
                              _size: usize, _n: usize, arg3: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE)
     -> libc::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> libc::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> libc::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _iprintf_r(arg1: *mut _reent, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn _iscanf_r(arg1: *mut _reent, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn _open_memstream_r(arg1: *mut _reent, arg2: *mut *mut libc::c_char,
                             arg3: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const libc::c_char);
}
extern "C" {
    pub fn _printf_r(arg1: *mut _reent, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn _putc_r(arg1: *mut _reent, arg2: libc::c_int, arg3: *mut FILE)
     -> libc::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(arg1: *mut _reent, arg2: libc::c_int,
                            arg3: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn _rename_r(arg1: *mut _reent, _old: *const libc::c_char,
                     _new: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn _siprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                       arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _siscanf_r(arg1: *mut _reent, arg2: *const libc::c_char,
                      arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _sniprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                        arg3: usize, arg4: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn _snprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                       arg3: usize, arg4: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn _sprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                      arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _sscanf_r(arg1: *mut _reent, arg2: *const libc::c_char,
                     arg3: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn _tempnam_r(arg1: *mut _reent, arg2: *const libc::c_char,
                      arg3: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _ungetc_r(arg1: *mut _reent, arg2: libc::c_int, arg3: *mut FILE)
     -> libc::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(arg1: *mut _reent, arg2: *mut *mut libc::c_char,
                         arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                          arg3: *mut usize, arg4: *const libc::c_char,
                          arg5: *mut __va_list_tag) -> *mut libc::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                         arg3: *mut usize, arg4: *const libc::c_char,
                         arg5: *mut __va_list_tag) -> *mut libc::c_char;
}
extern "C" {
    pub fn _vasprintf_r(arg1: *mut _reent, arg2: *mut *mut libc::c_char,
                        arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(arg1: *mut _reent, arg2: libc::c_int,
                        arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _vdprintf_r(arg1: *mut _reent, arg2: libc::c_int,
                       arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(arg1: *mut _reent, arg2: *mut FILE,
                        arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(arg1: *mut _reent, arg2: *mut FILE,
                       arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _vfprintf_r(arg1: *mut _reent, arg2: *mut FILE,
                       arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _vfscanf_r(arg1: *mut _reent, arg2: *mut FILE,
                      arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _viprintf_r(arg1: *mut _reent, arg2: *const libc::c_char,
                       arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn _viscanf_r(arg1: *mut _reent, arg2: *const libc::c_char,
                      arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn _vprintf_r(arg1: *mut _reent, arg2: *const libc::c_char,
                      arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn _vscanf_r(arg1: *mut _reent, arg2: *const libc::c_char,
                     arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                        arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(arg1: *mut _reent, arg2: *const libc::c_char,
                       arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                         arg3: usize, arg4: *const libc::c_char,
                         arg5: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                        arg3: usize, arg4: *const libc::c_char,
                        arg5: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn _vsprintf_r(arg1: *mut _reent, arg2: *mut libc::c_char,
                       arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn _vsscanf_r(arg1: *mut _reent, arg2: *const libc::c_char,
                      arg3: *const libc::c_char, arg4: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn __getdelim(arg1: *mut *mut libc::c_char, arg2: *mut usize,
                      arg3: libc::c_int, arg4: *mut FILE) -> isize;
}
extern "C" {
    pub fn __getline(arg1: *mut *mut libc::c_char, arg2: *mut usize,
                     arg3: *mut FILE) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread_unlocked(arg1: *mut libc::c_void, _size: usize, _n: usize,
                          arg2: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(arg1: *const libc::c_void, _size: usize, _n: usize,
                           arg2: *mut FILE) -> usize;
}
extern "C" {
    pub fn fgets_unlocked(arg1: *mut libc::c_char, arg2: libc::c_int,
                          arg3: *mut FILE) -> *mut libc::c_char;
}
extern "C" {
    pub fn fputs_unlocked(arg1: *const libc::c_char, arg2: *mut FILE)
     -> libc::c_int;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn __swbuf_r(arg1: *mut _reent, arg2: libc::c_int, arg3: *mut FILE)
     -> libc::c_int;
}
extern "C" {
    pub fn memchr(arg1: *const libc::c_void, arg2: libc::c_int, arg3: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn memcmp(arg1: *const libc::c_void, arg2: *const libc::c_void,
                  arg3: usize) -> libc::c_int;
}
extern "C" {
    pub fn memcpy(arg1: *mut libc::c_void, arg2: *const libc::c_void,
                  arg3: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(arg1: *mut libc::c_void, arg2: *const libc::c_void,
                   arg3: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset(arg1: *mut libc::c_void, arg2: libc::c_int, arg3: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn strcat(arg1: *mut libc::c_char, arg2: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const libc::c_char, arg2: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const libc::c_char, arg2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn strcoll(arg1: *const libc::c_char, arg2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut libc::c_char, arg2: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const libc::c_char, arg2: *const libc::c_char)
     -> usize;
}
extern "C" {
    pub fn strerror(arg1: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const libc::c_char) -> usize;
}
extern "C" {
    pub fn strncat(arg1: *mut libc::c_char, arg2: *const libc::c_char,
                   arg3: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncmp(arg1: *const libc::c_char, arg2: *const libc::c_char,
                   arg3: usize) -> libc::c_int;
}
extern "C" {
    pub fn strncpy(arg1: *mut libc::c_char, arg2: *const libc::c_char,
                   arg3: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn strpbrk(arg1: *const libc::c_char, arg2: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(arg1: *const libc::c_char, arg2: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const libc::c_char, arg2: *const libc::c_char)
     -> usize;
}
extern "C" {
    pub fn strstr(arg1: *const libc::c_char, arg2: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(arg1: *mut libc::c_char, arg2: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strxfrm(arg1: *mut libc::c_char, arg2: *const libc::c_char,
                   arg3: usize) -> usize;
}
extern "C" {
    pub fn strtok_r(arg1: *mut libc::c_char, arg2: *const libc::c_char,
                    arg3: *mut *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn bcmp(arg1: *const libc::c_void, arg2: *const libc::c_void,
                arg3: usize) -> libc::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const libc::c_void, arg2: *mut libc::c_void,
                 arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut libc::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn index(arg1: *const libc::c_char, arg2: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn memccpy(arg1: *mut libc::c_void, arg2: *const libc::c_void,
                   arg3: libc::c_int, arg4: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mempcpy(arg1: *mut libc::c_void, arg2: *const libc::c_void,
                   arg3: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmem(arg1: *const libc::c_void, arg2: usize,
                  arg3: *const libc::c_void, arg4: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn memrchr(arg1: *const libc::c_void, arg2: libc::c_int, arg3: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn rawmemchr(arg1: *const libc::c_void, arg2: libc::c_int)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn rindex(arg1: *const libc::c_char, arg2: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn stpcpy(arg1: *mut libc::c_char, arg2: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn stpncpy(arg1: *mut libc::c_char, arg2: *const libc::c_char,
                   arg3: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcasecmp(arg1: *const libc::c_char, arg2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn strcasestr(arg1: *const libc::c_char, arg2: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strchrnul(arg1: *const libc::c_char, arg2: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const libc::c_char, arg2: usize)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn ffsl(arg1: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn ffsll(arg1: libc::c_longlong) -> libc::c_int;
}
extern "C" {
    pub fn strerror_r(arg1: libc::c_int, arg2: *mut libc::c_char, arg3: usize)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn _strerror_r(arg1: *mut _reent, arg2: libc::c_int,
                       arg3: libc::c_int, arg4: *mut libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut libc::c_char, arg2: *const libc::c_char,
                   arg3: usize) -> usize;
}
extern "C" {
    pub fn strlcpy(arg1: *mut libc::c_char, arg2: *const libc::c_char,
                   arg3: usize) -> usize;
}
extern "C" {
    pub fn strncasecmp(arg1: *const libc::c_char, arg2: *const libc::c_char,
                       arg3: usize) -> libc::c_int;
}
extern "C" {
    pub fn strnlen(arg1: *const libc::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut libc::c_char, arg2: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strsignal(__signo: libc::c_int) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Copy)]
pub union __dmath {
    pub d: f64,
    pub i: [__ULong; 2usize],
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___dmath() {
    assert_eq!(::core::mem::size_of::<__dmath>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __dmath ) ));
    assert_eq! (::core::mem::align_of::<__dmath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __dmath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __dmath ) ) . d as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( __dmath ) , "::" ,
                stringify ! ( d ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __dmath ) ) . i as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( __dmath ) , "::" ,
                stringify ! ( i ) ));
}
impl Clone for __dmath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union __fmath {
    pub f: f32,
    pub i: [__ULong; 1usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___fmath() {
    assert_eq!(::core::mem::size_of::<__fmath>() , 4usize , concat ! (
               "Size of: " , stringify ! ( __fmath ) ));
    assert_eq! (::core::mem::align_of::<__fmath>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fmath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fmath ) ) . f as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fmath ) , "::" ,
                stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fmath ) ) . i as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fmath ) , "::" ,
                stringify ! ( i ) ));
}
impl Clone for __fmath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union __ldmath {
    pub ld: f64,
    pub i: [__ULong; 4usize],
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout___ldmath() {
    assert_eq!(::core::mem::size_of::<__ldmath>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __ldmath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ldmath ) ) . ld as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __ldmath ) , "::" ,
                stringify ! ( ld ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ldmath ) ) . i as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __ldmath ) , "::" ,
                stringify ! ( i ) ));
}
impl Clone for __ldmath {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __isinff(x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __isinfd(x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isnanf(x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __isnand(x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __fpclassifyf(x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __fpclassifyd(x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbitf(x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __signbitd(x: f64) -> libc::c_int;
}
extern "C" {
    pub fn infinity() -> f64;
}
extern "C" {
    pub fn nan(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> libc::c_int;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> libc::c_int;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: libc::c_long) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrint(arg1: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrint(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn lround(arg1: f64) -> libc::c_long;
}
extern "C" {
    pub fn llround(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: libc::c_int) -> f32;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: libc::c_long) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> libc::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> libc::c_long;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn infinityf() -> f32;
}
extern "C" {
    pub fn nanf(arg1: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn finitef(arg1: f32) -> libc::c_int;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> libc::c_int;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: libc::c_int) -> f32;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> libc::c_int;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: libc::c_long) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> libc::c_long;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sincos(arg1: f64, arg2: *mut f64, arg3: *mut f64);
}
extern "C" {
    pub fn gamma_r(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn sincosf(arg1: f32, arg2: *mut f32, arg3: *mut f32);
}
extern "C" {
    pub fn gammaf_r(arg1: f32, arg2: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn pow10(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn pow10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn itoa(val: libc::c_int, s: *mut libc::c_char, radix: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn ltoa(val: libc::c_long, s: *mut libc::c_char, radix: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn utoa(val: libc::c_uint, s: *mut libc::c_char, radix: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn ultoa(val: libc::c_ulong, s: *mut libc::c_char, radix: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn dtostrf(val: f64, width: libc::c_schar, prec: libc::c_uchar,
                   s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn reverse(begin: *mut libc::c_char, end: *mut libc::c_char);
}
pub type sint8_t = libc::c_schar;
pub type sint16_t = libc::c_short;
pub type sint32_t = libc::c_long;
pub type sint64_t = libc::c_longlong;
pub type u_int64_t = libc::c_ulonglong;
pub type real32_t = f32;
pub type real64_t = f64;
pub type uint8 = libc::c_uchar;
pub type u8 = libc::c_uchar;
pub type sint8 = libc::c_schar;
pub type int8 = libc::c_schar;
pub type s8 = libc::c_schar;
pub type uint16 = libc::c_ushort;
pub type u16 = libc::c_ushort;
pub type sint16 = libc::c_short;
pub type s16 = libc::c_short;
pub type uint32 = libc::c_uint;
pub type u32 = libc::c_uint;
pub type sint32 = libc::c_int;
pub type s32 = libc::c_int;
pub type int32 = libc::c_int;
pub type sint64 = libc::c_longlong;
pub type uint64 = libc::c_ulonglong;
pub type u64 = libc::c_ulonglong;
pub type real32 = f32;
pub type real64 = f64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum STATUS { OK = 0, FAIL = 1, PENDING = 2, BUSY = 3, CANCEL = 4, }
extern "C" {
    #[link_name = "esp8266_gpioToFn"]
    pub static mut esp8266_gpioToFn: [u8; 16usize];
}
extern "C" {
    pub fn twi_init(sda: libc::c_uchar, scl: libc::c_uchar);
}
extern "C" {
    pub fn twi_stop();
}
extern "C" {
    pub fn twi_setClock(freq: libc::c_uint);
}
extern "C" {
    pub fn twi_setClockStretchLimit(limit: u32);
}
extern "C" {
    pub fn twi_writeTo(address: libc::c_uchar, buf: *mut libc::c_uchar,
                       len: libc::c_uint, sendStop: libc::c_uchar) -> u8;
}
extern "C" {
    pub fn twi_readFrom(address: libc::c_uchar, buf: *mut libc::c_uchar,
                        len: libc::c_uint, sendStop: libc::c_uchar) -> u8;
}
extern "C" {
    pub fn twi_status() -> u8;
}
pub type timercallback = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn timer1_isr_init();
}
extern "C" {
    pub fn timer1_enable(divider: u8, int_type: u8, reload: u8);
}
extern "C" {
    pub fn timer1_disable();
}
extern "C" {
    pub fn timer1_attachInterrupt(userFunc: timercallback);
}
extern "C" {
    pub fn timer1_detachInterrupt();
}
extern "C" {
    pub fn timer1_write(ticks: u32);
}
extern "C" {
    pub fn timer0_isr_init();
}
extern "C" {
    pub fn timer0_attachInterrupt(userFunc: timercallback);
}
extern "C" {
    pub fn timer0_detachInterrupt();
}
extern "C" {
    pub fn ets_intr_lock();
}
extern "C" {
    pub fn ets_intr_unlock();
}
pub type word = libc::c_uint;
pub type boolean = u8;
pub type byte = u8;
extern "C" {
    pub fn init();
}
extern "C" {
    pub fn initVariant();
}
extern "C" {
    pub fn pinMode(pin: u8, mode: u8);
}
extern "C" {
    pub fn digitalWrite(pin: u8, val: u8);
}
extern "C" {
    pub fn digitalRead(pin: u8) -> libc::c_int;
}
extern "C" {
    pub fn analogRead(pin: u8) -> libc::c_int;
}
extern "C" {
    pub fn analogReference(mode: u8);
}
extern "C" {
    pub fn analogWrite(pin: u8, val: libc::c_int);
}
extern "C" {
    pub fn analogWriteFreq(freq: u32);
}
extern "C" {
    pub fn analogWriteRange(range: u32);
}
extern "C" {
    pub fn millis() -> libc::c_ulong;
}
extern "C" {
    pub fn micros() -> libc::c_ulong;
}
extern "C" {
    pub fn delay(arg1: libc::c_ulong);
}
extern "C" {
    pub fn delayMicroseconds(us: libc::c_uint);
}
extern "C" {
    pub fn pulseIn(pin: u8, state: u8, timeout: libc::c_ulong)
     -> libc::c_ulong;
}
extern "C" {
    pub fn pulseInLong(pin: u8, state: u8, timeout: libc::c_ulong)
     -> libc::c_ulong;
}
extern "C" {
    pub fn shiftOut(dataPin: u8, clockPin: u8, bitOrder: u8, val: u8);
}
extern "C" {
    pub fn shiftIn(dataPin: u8, clockPin: u8, bitOrder: u8) -> u8;
}
extern "C" {
    pub fn attachInterrupt(pin: u8,
                           arg1:
                               ::core::option::Option<unsafe extern "C" fn()>,
                           mode: libc::c_int);
}
extern "C" {
    pub fn detachInterrupt(pin: u8);
}
extern "C" {
    pub fn setup();
}
extern "C" {
    #[link_name = "loop"]
    pub fn loop_();
}
extern "C" {
    #[link_name = "yield"]
    pub fn yield_();
}
extern "C" {
    pub fn optimistic_yield(interval_us: u32);
}
pub type prog_void = libc::c_void;
pub type prog_char = libc::c_char;
pub type prog_uchar = libc::c_uchar;
pub type prog_int8_t = i8;
pub type prog_uint8_t = u8;
pub type prog_int16_t = i16;
pub type prog_uint16_t = u16;
pub type prog_int32_t = i32;
pub type prog_uint32_t = u32;
extern "C" {
    #[link_name = "_Z8memcmp_PPKvS0_m"]
    pub fn memcmp_P(buf1: *const libc::c_void, buf2P: *const libc::c_void,
                    size: usize) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z9memccpy_PPvPKvim"]
    pub fn memccpy_P(dest: *mut libc::c_void, src: *const libc::c_void,
                     c: libc::c_int, count: usize) -> *mut libc::c_void;
}
extern "C" {
    #[link_name = "_Z8memmem_PPKvmS0_m"]
    pub fn memmem_P(buf: *const libc::c_void, bufSize: usize,
                    findP: *const libc::c_void, findPSize: usize)
     -> *mut libc::c_void;
}
extern "C" {
    #[link_name = "_Z8memcpy_PPvPKvm"]
    pub fn memcpy_P(dest: *mut libc::c_void, src: *const libc::c_void,
                    count: usize) -> *mut libc::c_void;
}
extern "C" {
    #[link_name = "_Z9strncpy_PPcPKcm"]
    pub fn strncpy_P(dest: *mut libc::c_char, src: *const libc::c_char,
                     size: usize) -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "_Z9strncat_PPcPKcm"]
    pub fn strncat_P(dest: *mut libc::c_char, src: *const libc::c_char,
                     size: usize) -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "_Z9strncmp_PPKcS0_m"]
    pub fn strncmp_P(str1: *const libc::c_char, str2P: *const libc::c_char,
                     size: usize) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z13strncasecmp_PPKcS0_m"]
    pub fn strncasecmp_P(str1: *const libc::c_char,
                         str2P: *const libc::c_char, size: usize)
     -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z9strnlen_PPKcm"]
    pub fn strnlen_P(s: *const libc::c_char, size: usize) -> usize;
}
extern "C" {
    #[link_name = "_Z8strstr_PPKcS0_"]
    pub fn strstr_P(haystack: *const libc::c_char,
                    needle: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "_Z8printf_PPKcz"]
    pub fn printf_P(formatP: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z9sprintf_PPcPKcz"]
    pub fn sprintf_P(str: *mut libc::c_char,
                     formatP: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z10snprintf_PPcmPKcz"]
    pub fn snprintf_P(str: *mut libc::c_char, strSize: usize,
                      formatP: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z11vsnprintf_PPcmPKcP13__va_list_tag"]
    pub fn vsnprintf_P(str: *mut libc::c_char, strSize: usize,
                       formatP: *const libc::c_char, ap: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn isalnum(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isalpha(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn iscntrl(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isdigit(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isgraph(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn islower(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isprint(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ispunct(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isspace(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isupper(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isxdigit(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn tolower(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn toupper(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isblank(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[link_name = "__ctype_ptr__"]
    pub static mut __ctype_ptr__: *const libc::c_char;
}
extern "C" {
    #[link_name = "_ctype_"]
    pub static mut _ctype_: [libc::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug)]
pub struct StringSumHelper {
    pub _base: String,
}
#[test]
fn bindgen_test_layout_StringSumHelper() {
    assert_eq!(::core::mem::size_of::<StringSumHelper>() , 16usize , concat !
               ( "Size of: " , stringify ! ( StringSumHelper ) ));
    assert_eq! (::core::mem::align_of::<StringSumHelper>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( StringSumHelper ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __FlashStringHelper {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct String {
    pub buffer: *mut libc::c_char,
    pub capacity: libc::c_uint,
    pub len: libc::c_uint,
}
pub type String_StringIfHelperType =
    ::core::option::Option<unsafe extern "C" fn()>;
#[test]
fn bindgen_test_layout_String() {
    assert_eq!(::core::mem::size_of::<String>() , 16usize , concat ! (
               "Size of: " , stringify ! ( String ) ));
    assert_eq! (::core::mem::align_of::<String>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( String ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const String ) ) . buffer as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( String ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const String ) ) . capacity as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( String ) , "::" ,
                stringify ! ( capacity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const String ) ) . len as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( String ) , "::" ,
                stringify ! ( len ) ));
}
extern "C" {
    #[link_name = "_ZN6String7reserveEj"]
    pub fn String_reserve(this: *mut String, size: libc::c_uint)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatERKS_"]
    pub fn String_concat(this: *mut String, str: *const String)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEPKc"]
    pub fn String_concat1(this: *mut String, cstr: *const libc::c_char)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEc"]
    pub fn String_concat2(this: *mut String, c: libc::c_char)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEh"]
    pub fn String_concat3(this: *mut String, c: libc::c_uchar)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEi"]
    pub fn String_concat4(this: *mut String, num: libc::c_int)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEj"]
    pub fn String_concat5(this: *mut String, num: libc::c_uint)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEl"]
    pub fn String_concat6(this: *mut String, num: libc::c_long)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEm"]
    pub fn String_concat7(this: *mut String, num: libc::c_ulong)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEf"]
    pub fn String_concat8(this: *mut String, num: f32) -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEd"]
    pub fn String_concat9(this: *mut String, num: f64) -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEPK19__FlashStringHelper"]
    pub fn String_concat10(this: *mut String, str: *const __FlashStringHelper)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZNK6String9compareToERKS_"]
    pub fn String_compareTo(this: *const String, s: *const String)
     -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZNK6String6equalsERKS_"]
    pub fn String_equals(this: *const String, s: *const String)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZNK6String6equalsEPKc"]
    pub fn String_equals1(this: *const String, cstr: *const libc::c_char)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZNK6String16equalsIgnoreCaseERKS_"]
    pub fn String_equalsIgnoreCase(this: *const String, s: *const String)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZNK6String10startsWithERKS_"]
    pub fn String_startsWith(this: *const String, prefix: *const String)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZNK6String10startsWithERKS_j"]
    pub fn String_startsWith1(this: *const String, prefix: *const String,
                              offset: libc::c_uint) -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZNK6String8endsWithERKS_"]
    pub fn String_endsWith(this: *const String, suffix: *const String)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZNK6String6charAtEj"]
    pub fn String_charAt(this: *const String, index: libc::c_uint)
     -> libc::c_char;
}
extern "C" {
    #[link_name = "_ZN6String9setCharAtEjc"]
    pub fn String_setCharAt(this: *mut String, index: libc::c_uint,
                            c: libc::c_char);
}
extern "C" {
    #[link_name = "_ZNK6String8getBytesEPhjj"]
    pub fn String_getBytes(this: *const String, buf: *mut libc::c_uchar,
                           bufsize: libc::c_uint, index: libc::c_uint);
}
extern "C" {
    #[link_name = "_ZNK6String7indexOfEc"]
    pub fn String_indexOf(this: *const String, ch: libc::c_char)
     -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZNK6String7indexOfEcj"]
    pub fn String_indexOf1(this: *const String, ch: libc::c_char,
                           fromIndex: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZNK6String7indexOfERKS_"]
    pub fn String_indexOf2(this: *const String, str: *const String)
     -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZNK6String7indexOfERKS_j"]
    pub fn String_indexOf3(this: *const String, str: *const String,
                           fromIndex: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZNK6String11lastIndexOfEc"]
    pub fn String_lastIndexOf(this: *const String, ch: libc::c_char)
     -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZNK6String11lastIndexOfEcj"]
    pub fn String_lastIndexOf1(this: *const String, ch: libc::c_char,
                               fromIndex: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZNK6String11lastIndexOfERKS_"]
    pub fn String_lastIndexOf2(this: *const String, str: *const String)
     -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZNK6String11lastIndexOfERKS_j"]
    pub fn String_lastIndexOf3(this: *const String, str: *const String,
                               fromIndex: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZNK6String9substringEjj"]
    pub fn String_substring(this: *const String, beginIndex: libc::c_uint,
                            endIndex: libc::c_uint) -> String;
}
extern "C" {
    #[link_name = "_ZN6String7replaceEcc"]
    pub fn String_replace(this: *mut String, find: libc::c_char,
                          replace: libc::c_char);
}
extern "C" {
    #[link_name = "_ZN6String7replaceERKS_S1_"]
    pub fn String_replace1(this: *mut String, find: *const String,
                           replace: *const String);
}
extern "C" {
    #[link_name = "_ZN6String6removeEj"]
    pub fn String_remove(this: *mut String, index: libc::c_uint);
}
extern "C" {
    #[link_name = "_ZN6String6removeEjj"]
    pub fn String_remove1(this: *mut String, index: libc::c_uint,
                          count: libc::c_uint);
}
extern "C" {
    #[link_name = "_ZN6String11toLowerCaseEv"]
    pub fn String_toLowerCase(this: *mut String);
}
extern "C" {
    #[link_name = "_ZN6String11toUpperCaseEv"]
    pub fn String_toUpperCase(this: *mut String);
}
extern "C" {
    #[link_name = "_ZN6String4trimEv"]
    pub fn String_trim(this: *mut String);
}
extern "C" {
    #[link_name = "_ZNK6String5toIntEv"]
    pub fn String_toInt(this: *const String) -> libc::c_long;
}
extern "C" {
    #[link_name = "_ZNK6String7toFloatEv"]
    pub fn String_toFloat(this: *const String) -> f32;
}
extern "C" {
    #[link_name = "_ZN6String4initEv"]
    pub fn String_init(this: *mut String);
}
extern "C" {
    #[link_name = "_ZN6String10invalidateEv"]
    pub fn String_invalidate(this: *mut String);
}
extern "C" {
    #[link_name = "_ZN6String12changeBufferEj"]
    pub fn String_changeBuffer(this: *mut String, maxStrLen: libc::c_uint)
     -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String6concatEPKcj"]
    pub fn String_concat11(this: *mut String, cstr: *const libc::c_char,
                           length: libc::c_uint) -> libc::c_uchar;
}
extern "C" {
    #[link_name = "_ZN6String4copyEPKcj"]
    pub fn String_copy(this: *mut String, cstr: *const libc::c_char,
                       length: libc::c_uint) -> *mut String;
}
extern "C" {
    #[link_name = "_ZN6String4copyEPK19__FlashStringHelperj"]
    pub fn String_copy1(this: *mut String, pstr: *const __FlashStringHelper,
                        length: libc::c_uint) -> *mut String;
}
extern "C" {
    #[link_name = "_ZN6String4moveERS_"]
    pub fn String_move(this: *mut String, rhs: *mut String);
}
extern "C" {
    #[link_name = "_ZN6StringC1EPKc"]
    pub fn String_String(this: *mut String, cstr: *const libc::c_char);
}
extern "C" {
    #[link_name = "_ZN6StringC1ERKS_"]
    pub fn String_String1(this: *mut String, str: *const String);
}
extern "C" {
    #[link_name = "_ZN6StringC1EPK19__FlashStringHelper"]
    pub fn String_String2(this: *mut String, str: *const __FlashStringHelper);
}
extern "C" {
    #[link_name = "_ZN6StringC1EOS_"]
    pub fn String_String3(this: *mut String, rval: *mut String);
}
extern "C" {
    #[link_name = "_ZN6StringC1EO15StringSumHelper"]
    pub fn String_String4(this: *mut String, rval: *mut StringSumHelper);
}
extern "C" {
    #[link_name = "_ZN6StringC1Ec"]
    pub fn String_String5(this: *mut String, c: libc::c_char);
}
extern "C" {
    #[link_name = "_ZN6StringC1Ehh"]
    pub fn String_String6(this: *mut String, arg1: libc::c_uchar,
                          base: libc::c_uchar);
}
extern "C" {
    #[link_name = "_ZN6StringC1Eih"]
    pub fn String_String7(this: *mut String, arg1: libc::c_int,
                          base: libc::c_uchar);
}
extern "C" {
    #[link_name = "_ZN6StringC1Ejh"]
    pub fn String_String8(this: *mut String, arg1: libc::c_uint,
                          base: libc::c_uchar);
}
extern "C" {
    #[link_name = "_ZN6StringC1Elh"]
    pub fn String_String9(this: *mut String, arg1: libc::c_long,
                          base: libc::c_uchar);
}
extern "C" {
    #[link_name = "_ZN6StringC1Emh"]
    pub fn String_String10(this: *mut String, arg1: libc::c_ulong,
                           base: libc::c_uchar);
}
extern "C" {
    #[link_name = "_ZN6StringC1Efh"]
    pub fn String_String11(this: *mut String, arg1: f32,
                           decimalPlaces: libc::c_uchar);
}
extern "C" {
    #[link_name = "_ZN6StringC1Edh"]
    pub fn String_String12(this: *mut String, arg1: f64,
                           decimalPlaces: libc::c_uchar);
}
extern "C" {
    #[link_name = "_ZN6StringD1Ev"]
    pub fn String_String_destructor(this: *mut String);
}
impl String {
    #[inline]
    pub unsafe fn reserve(&mut self, size: libc::c_uint) -> libc::c_uchar {
        String_reserve(self, size)
    }
    #[inline]
    pub unsafe fn concat(&mut self, str: *const String) -> libc::c_uchar {
        String_concat(self, str)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, cstr: *const libc::c_char)
     -> libc::c_uchar {
        String_concat1(self, cstr)
    }
    #[inline]
    pub unsafe fn concat2(&mut self, c: libc::c_char) -> libc::c_uchar {
        String_concat2(self, c)
    }
    #[inline]
    pub unsafe fn concat3(&mut self, c: libc::c_uchar) -> libc::c_uchar {
        String_concat3(self, c)
    }
    #[inline]
    pub unsafe fn concat4(&mut self, num: libc::c_int) -> libc::c_uchar {
        String_concat4(self, num)
    }
    #[inline]
    pub unsafe fn concat5(&mut self, num: libc::c_uint) -> libc::c_uchar {
        String_concat5(self, num)
    }
    #[inline]
    pub unsafe fn concat6(&mut self, num: libc::c_long) -> libc::c_uchar {
        String_concat6(self, num)
    }
    #[inline]
    pub unsafe fn concat7(&mut self, num: libc::c_ulong) -> libc::c_uchar {
        String_concat7(self, num)
    }
    #[inline]
    pub unsafe fn concat8(&mut self, num: f32) -> libc::c_uchar {
        String_concat8(self, num)
    }
    #[inline]
    pub unsafe fn concat9(&mut self, num: f64) -> libc::c_uchar {
        String_concat9(self, num)
    }
    #[inline]
    pub unsafe fn concat10(&mut self, str: *const __FlashStringHelper)
     -> libc::c_uchar {
        String_concat10(self, str)
    }
    #[inline]
    pub unsafe fn compareTo(&self, s: *const String) -> libc::c_int {
        String_compareTo(self, s)
    }
    #[inline]
    pub unsafe fn equals(&self, s: *const String) -> libc::c_uchar {
        String_equals(self, s)
    }
    #[inline]
    pub unsafe fn equals1(&self, cstr: *const libc::c_char) -> libc::c_uchar {
        String_equals1(self, cstr)
    }
    #[inline]
    pub unsafe fn equalsIgnoreCase(&self, s: *const String) -> libc::c_uchar {
        String_equalsIgnoreCase(self, s)
    }
    #[inline]
    pub unsafe fn startsWith(&self, prefix: *const String) -> libc::c_uchar {
        String_startsWith(self, prefix)
    }
    #[inline]
    pub unsafe fn startsWith1(&self, prefix: *const String,
                              offset: libc::c_uint) -> libc::c_uchar {
        String_startsWith1(self, prefix, offset)
    }
    #[inline]
    pub unsafe fn endsWith(&self, suffix: *const String) -> libc::c_uchar {
        String_endsWith(self, suffix)
    }
    #[inline]
    pub unsafe fn charAt(&self, index: libc::c_uint) -> libc::c_char {
        String_charAt(self, index)
    }
    #[inline]
    pub unsafe fn setCharAt(&mut self, index: libc::c_uint, c: libc::c_char) {
        String_setCharAt(self, index, c)
    }
    #[inline]
    pub unsafe fn getBytes(&self, buf: *mut libc::c_uchar,
                           bufsize: libc::c_uint, index: libc::c_uint) {
        String_getBytes(self, buf, bufsize, index)
    }
    #[inline]
    pub unsafe fn indexOf(&self, ch: libc::c_char) -> libc::c_int {
        String_indexOf(self, ch)
    }
    #[inline]
    pub unsafe fn indexOf1(&self, ch: libc::c_char, fromIndex: libc::c_uint)
     -> libc::c_int {
        String_indexOf1(self, ch, fromIndex)
    }
    #[inline]
    pub unsafe fn indexOf2(&self, str: *const String) -> libc::c_int {
        String_indexOf2(self, str)
    }
    #[inline]
    pub unsafe fn indexOf3(&self, str: *const String, fromIndex: libc::c_uint)
     -> libc::c_int {
        String_indexOf3(self, str, fromIndex)
    }
    #[inline]
    pub unsafe fn lastIndexOf(&self, ch: libc::c_char) -> libc::c_int {
        String_lastIndexOf(self, ch)
    }
    #[inline]
    pub unsafe fn lastIndexOf1(&self, ch: libc::c_char,
                               fromIndex: libc::c_uint) -> libc::c_int {
        String_lastIndexOf1(self, ch, fromIndex)
    }
    #[inline]
    pub unsafe fn lastIndexOf2(&self, str: *const String) -> libc::c_int {
        String_lastIndexOf2(self, str)
    }
    #[inline]
    pub unsafe fn lastIndexOf3(&self, str: *const String,
                               fromIndex: libc::c_uint) -> libc::c_int {
        String_lastIndexOf3(self, str, fromIndex)
    }
    #[inline]
    pub unsafe fn substring(&self, beginIndex: libc::c_uint,
                            endIndex: libc::c_uint) -> String {
        String_substring(self, beginIndex, endIndex)
    }
    #[inline]
    pub unsafe fn replace(&mut self, find: libc::c_char,
                          replace: libc::c_char) {
        String_replace(self, find, replace)
    }
    #[inline]
    pub unsafe fn replace1(&mut self, find: *const String,
                           replace: *const String) {
        String_replace1(self, find, replace)
    }
    #[inline]
    pub unsafe fn remove(&mut self, index: libc::c_uint) {
        String_remove(self, index)
    }
    #[inline]
    pub unsafe fn remove1(&mut self, index: libc::c_uint,
                          count: libc::c_uint) {
        String_remove1(self, index, count)
    }
    #[inline]
    pub unsafe fn toLowerCase(&mut self) { String_toLowerCase(self) }
    #[inline]
    pub unsafe fn toUpperCase(&mut self) { String_toUpperCase(self) }
    #[inline]
    pub unsafe fn trim(&mut self) { String_trim(self) }
    #[inline]
    pub unsafe fn toInt(&self) -> libc::c_long { String_toInt(self) }
    #[inline]
    pub unsafe fn toFloat(&self) -> f32 { String_toFloat(self) }
    #[inline]
    pub unsafe fn init(&mut self) { String_init(self) }
    #[inline]
    pub unsafe fn invalidate(&mut self) { String_invalidate(self) }
    #[inline]
    pub unsafe fn changeBuffer(&mut self, maxStrLen: libc::c_uint)
     -> libc::c_uchar {
        String_changeBuffer(self, maxStrLen)
    }
    #[inline]
    pub unsafe fn concat11(&mut self, cstr: *const libc::c_char,
                           length: libc::c_uint) -> libc::c_uchar {
        String_concat11(self, cstr, length)
    }
    #[inline]
    pub unsafe fn copy(&mut self, cstr: *const libc::c_char,
                       length: libc::c_uint) -> *mut String {
        String_copy(self, cstr, length)
    }
    #[inline]
    pub unsafe fn copy1(&mut self, pstr: *const __FlashStringHelper,
                        length: libc::c_uint) -> *mut String {
        String_copy1(self, pstr, length)
    }
    #[inline]
    pub unsafe fn move_(&mut self, rhs: *mut String) {
        String_move(self, rhs)
    }
    #[inline]
    pub unsafe fn new(cstr: *const libc::c_char) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String(&mut __bindgen_tmp, cstr);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(str: *const String) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String1(&mut __bindgen_tmp, str);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(str: *const __FlashStringHelper) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String2(&mut __bindgen_tmp, str);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(rval: *mut String) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String3(&mut __bindgen_tmp, rval);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(rval: *mut StringSumHelper) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String4(&mut __bindgen_tmp, rval);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new5(c: libc::c_char) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String5(&mut __bindgen_tmp, c);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new6(arg1: libc::c_uchar, base: libc::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String6(&mut __bindgen_tmp, arg1, base);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new7(arg1: libc::c_int, base: libc::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String7(&mut __bindgen_tmp, arg1, base);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new8(arg1: libc::c_uint, base: libc::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String8(&mut __bindgen_tmp, arg1, base);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new9(arg1: libc::c_long, base: libc::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String9(&mut __bindgen_tmp, arg1, base);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new10(arg1: libc::c_ulong, base: libc::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String10(&mut __bindgen_tmp, arg1, base);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new11(arg1: f32, decimalPlaces: libc::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String11(&mut __bindgen_tmp, arg1, decimalPlaces);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new12(arg1: f64, decimalPlaces: libc::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        String_String12(&mut __bindgen_tmp, arg1, decimalPlaces);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) { String_String_destructor(self) }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(::core::mem::size_of::<imaxdiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (::core::mem::align_of::<imaxdiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for imaxdiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char,
                     arg3: libc::c_int) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char,
                     arg3: libc::c_int) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(arg1: *const u16, arg2: *mut *mut u16, arg3: libc::c_int)
     -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(arg1: *const u16, arg2: *mut *mut u16, arg3: libc::c_int)
     -> uintmax_t;
}
#[repr(C)]
pub struct Print__bindgen_vtable(libc::c_void);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Print {
    pub vtable_: *const Print__bindgen_vtable,
    pub write_error: libc::c_int,
}
#[test]
fn bindgen_test_layout_Print() {
    assert_eq!(::core::mem::size_of::<Print>() , 16usize , concat ! (
               "Size of: " , stringify ! ( Print ) ));
    assert_eq! (::core::mem::align_of::<Print>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Print ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Print ) ) . write_error as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Print ) , "::" ,
                stringify ! ( write_error ) ));
}
extern "C" {
    #[link_name = "_ZN5Print6printfEPKcz"]
    pub fn Print_printf(this: *mut Print, format: *const libc::c_char, ...)
     -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print8printf_PEPKcz"]
    pub fn Print_printf_P(this: *mut Print, format: *const libc::c_char, ...)
     -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printEPK19__FlashStringHelper"]
    pub fn Print_print(this: *mut Print, arg1: *const __FlashStringHelper)
     -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printERK6String"]
    pub fn Print_print1(this: *mut Print, arg1: *const String) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printEPKc"]
    pub fn Print_print2(this: *mut Print, arg1: *const libc::c_char) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printEc"]
    pub fn Print_print3(this: *mut Print, arg1: libc::c_char) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printEhi"]
    pub fn Print_print4(this: *mut Print, arg1: libc::c_uchar,
                        arg2: libc::c_int) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printEii"]
    pub fn Print_print5(this: *mut Print, arg1: libc::c_int,
                        arg2: libc::c_int) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printEji"]
    pub fn Print_print6(this: *mut Print, arg1: libc::c_uint,
                        arg2: libc::c_int) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printEli"]
    pub fn Print_print7(this: *mut Print, arg1: libc::c_long,
                        arg2: libc::c_int) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printEmi"]
    pub fn Print_print8(this: *mut Print, arg1: libc::c_ulong,
                        arg2: libc::c_int) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printEdi"]
    pub fn Print_print9(this: *mut Print, arg1: f64, arg2: libc::c_int)
     -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5printERK9Printable"]
    pub fn Print_print10(this: *mut Print, arg1: *const Printable) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnEPK19__FlashStringHelper"]
    pub fn Print_println(this: *mut Print, arg1: *const __FlashStringHelper)
     -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnERK6String"]
    pub fn Print_println1(this: *mut Print, s: *const String) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnEPKc"]
    pub fn Print_println2(this: *mut Print, arg1: *const libc::c_char)
     -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnEc"]
    pub fn Print_println3(this: *mut Print, arg1: libc::c_char) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnEhi"]
    pub fn Print_println4(this: *mut Print, arg1: libc::c_uchar,
                          arg2: libc::c_int) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnEii"]
    pub fn Print_println5(this: *mut Print, arg1: libc::c_int,
                          arg2: libc::c_int) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnEji"]
    pub fn Print_println6(this: *mut Print, arg1: libc::c_uint,
                          arg2: libc::c_int) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnEli"]
    pub fn Print_println7(this: *mut Print, arg1: libc::c_long,
                          arg2: libc::c_int) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnEmi"]
    pub fn Print_println8(this: *mut Print, arg1: libc::c_ulong,
                          arg2: libc::c_int) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnEdi"]
    pub fn Print_println9(this: *mut Print, arg1: f64, arg2: libc::c_int)
     -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnERK9Printable"]
    pub fn Print_println10(this: *mut Print, arg1: *const Printable) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print7printlnEv"]
    pub fn Print_println11(this: *mut Print) -> usize;
}
impl Clone for Print {
    fn clone(&self) -> Self { *self }
}
impl Print {
    #[inline]
    pub unsafe fn print(&mut self, arg1: *const __FlashStringHelper)
     -> usize {
        Print_print(self, arg1)
    }
    #[inline]
    pub unsafe fn print1(&mut self, arg1: *const String) -> usize {
        Print_print1(self, arg1)
    }
    #[inline]
    pub unsafe fn print2(&mut self, arg1: *const libc::c_char) -> usize {
        Print_print2(self, arg1)
    }
    #[inline]
    pub unsafe fn print3(&mut self, arg1: libc::c_char) -> usize {
        Print_print3(self, arg1)
    }
    #[inline]
    pub unsafe fn print4(&mut self, arg1: libc::c_uchar, arg2: libc::c_int)
     -> usize {
        Print_print4(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print5(&mut self, arg1: libc::c_int, arg2: libc::c_int)
     -> usize {
        Print_print5(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print6(&mut self, arg1: libc::c_uint, arg2: libc::c_int)
     -> usize {
        Print_print6(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print7(&mut self, arg1: libc::c_long, arg2: libc::c_int)
     -> usize {
        Print_print7(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print8(&mut self, arg1: libc::c_ulong, arg2: libc::c_int)
     -> usize {
        Print_print8(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print9(&mut self, arg1: f64, arg2: libc::c_int) -> usize {
        Print_print9(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print10(&mut self, arg1: *const Printable) -> usize {
        Print_print10(self, arg1)
    }
    #[inline]
    pub unsafe fn println(&mut self, arg1: *const __FlashStringHelper)
     -> usize {
        Print_println(self, arg1)
    }
    #[inline]
    pub unsafe fn println1(&mut self, s: *const String) -> usize {
        Print_println1(self, s)
    }
    #[inline]
    pub unsafe fn println2(&mut self, arg1: *const libc::c_char) -> usize {
        Print_println2(self, arg1)
    }
    #[inline]
    pub unsafe fn println3(&mut self, arg1: libc::c_char) -> usize {
        Print_println3(self, arg1)
    }
    #[inline]
    pub unsafe fn println4(&mut self, arg1: libc::c_uchar, arg2: libc::c_int)
     -> usize {
        Print_println4(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println5(&mut self, arg1: libc::c_int, arg2: libc::c_int)
     -> usize {
        Print_println5(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println6(&mut self, arg1: libc::c_uint, arg2: libc::c_int)
     -> usize {
        Print_println6(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println7(&mut self, arg1: libc::c_long, arg2: libc::c_int)
     -> usize {
        Print_println7(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println8(&mut self, arg1: libc::c_ulong, arg2: libc::c_int)
     -> usize {
        Print_println8(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println9(&mut self, arg1: f64, arg2: libc::c_int) -> usize {
        Print_println9(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println10(&mut self, arg1: *const Printable) -> usize {
        Print_println10(self, arg1)
    }
    #[inline]
    pub unsafe fn println11(&mut self) -> usize { Print_println11(self) }
}
extern "C" {
    #[link_name = "_ZN5Print5writeEh"]
    pub fn Print_write(this: *mut libc::c_void, arg1: u8) -> usize;
}
extern "C" {
    #[link_name = "_ZN5Print5writeEPKhm"]
    pub fn Print_write1(this: *mut libc::c_void, buffer: *const u8,
                        size: usize) -> usize;
}
#[repr(C)]
pub struct Printable__bindgen_vtable(libc::c_void);
/// The Printable class provides a way for new classes to allow themselves to be printed.
/// By deriving from Printable and implementing the printTo method, it will then be possible
/// for users to print out instances of this class by passing them into the usual
/// Print::print and Print::println methods.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Printable {
    pub vtable_: *const Printable__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_Printable() {
    assert_eq!(::core::mem::size_of::<Printable>() , 8usize , concat ! (
               "Size of: " , stringify ! ( Printable ) ));
    assert_eq! (::core::mem::align_of::<Printable>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Printable ) ));
}
impl Clone for Printable {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_ZNK9Printable7printToER5Print"]
    pub fn Printable_printTo(this: *mut libc::c_void, p: *mut Print) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Stream {
    pub _base: Print,
    pub _timeout: libc::c_ulong,
    pub _startMillis: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_Stream() {
    assert_eq!(::core::mem::size_of::<Stream>() , 32usize , concat ! (
               "Size of: " , stringify ! ( Stream ) ));
    assert_eq! (::core::mem::align_of::<Stream>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Stream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Stream ) ) . _timeout as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Stream ) , "::" ,
                stringify ! ( _timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Stream ) ) . _startMillis as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Stream ) , "::" ,
                stringify ! ( _startMillis ) ));
}
extern "C" {
    #[link_name = "_ZN6Stream9timedReadEv"]
    pub fn Stream_timedRead(this: *mut Stream) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN6Stream9timedPeekEv"]
    pub fn Stream_timedPeek(this: *mut Stream) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN6Stream13peekNextDigitEv"]
    pub fn Stream_peekNextDigit(this: *mut Stream) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN6Stream10setTimeoutEm"]
    pub fn Stream_setTimeout(this: *mut Stream, timeout: libc::c_ulong);
}
extern "C" {
    #[link_name = "_ZN6Stream4findEPKc"]
    pub fn Stream_find(this: *mut Stream, target: *const libc::c_char)
     -> bool;
}
extern "C" {
    #[link_name = "_ZN6Stream4findEPKcm"]
    pub fn Stream_find1(this: *mut Stream, target: *const libc::c_char,
                        length: usize) -> bool;
}
extern "C" {
    #[link_name = "_ZN6Stream9findUntilEPKcS1_"]
    pub fn Stream_findUntil(this: *mut Stream, target: *const libc::c_char,
                            terminator: *const libc::c_char) -> bool;
}
extern "C" {
    #[link_name = "_ZN6Stream9findUntilEPKcmS1_m"]
    pub fn Stream_findUntil1(this: *mut Stream, target: *const libc::c_char,
                             targetLen: usize, terminate: *const libc::c_char,
                             termLen: usize) -> bool;
}
extern "C" {
    #[link_name = "_ZN6Stream8parseIntEv"]
    pub fn Stream_parseInt(this: *mut Stream) -> libc::c_long;
}
extern "C" {
    #[link_name = "_ZN6Stream10parseFloatEv"]
    pub fn Stream_parseFloat(this: *mut Stream) -> f32;
}
extern "C" {
    #[link_name = "_ZN6Stream14readBytesUntilEcPcm"]
    pub fn Stream_readBytesUntil(this: *mut Stream, terminator: libc::c_char,
                                 buffer: *mut libc::c_char, length: usize)
     -> usize;
}
extern "C" {
    #[link_name = "_ZN6Stream10readStringEv"]
    pub fn Stream_readString(this: *mut Stream) -> String;
}
extern "C" {
    #[link_name = "_ZN6Stream15readStringUntilEc"]
    pub fn Stream_readStringUntil(this: *mut Stream, terminator: libc::c_char)
     -> String;
}
extern "C" {
    #[link_name = "_ZN6Stream8parseIntEc"]
    pub fn Stream_parseInt1(this: *mut Stream, skipChar: libc::c_char)
     -> libc::c_long;
}
extern "C" {
    #[link_name = "_ZN6Stream10parseFloatEc"]
    pub fn Stream_parseFloat1(this: *mut Stream, skipChar: libc::c_char)
     -> f32;
}
impl Clone for Stream {
    fn clone(&self) -> Self { *self }
}
impl Stream {
    #[inline]
    pub unsafe fn timedRead(&mut self) -> libc::c_int {
        Stream_timedRead(self)
    }
    #[inline]
    pub unsafe fn timedPeek(&mut self) -> libc::c_int {
        Stream_timedPeek(self)
    }
    #[inline]
    pub unsafe fn peekNextDigit(&mut self) -> libc::c_int {
        Stream_peekNextDigit(self)
    }
    #[inline]
    pub unsafe fn setTimeout(&mut self, timeout: libc::c_ulong) {
        Stream_setTimeout(self, timeout)
    }
    #[inline]
    pub unsafe fn find(&mut self, target: *const libc::c_char) -> bool {
        Stream_find(self, target)
    }
    #[inline]
    pub unsafe fn find1(&mut self, target: *const libc::c_char, length: usize)
     -> bool {
        Stream_find1(self, target, length)
    }
    #[inline]
    pub unsafe fn findUntil(&mut self, target: *const libc::c_char,
                            terminator: *const libc::c_char) -> bool {
        Stream_findUntil(self, target, terminator)
    }
    #[inline]
    pub unsafe fn findUntil1(&mut self, target: *const libc::c_char,
                             targetLen: usize, terminate: *const libc::c_char,
                             termLen: usize) -> bool {
        Stream_findUntil1(self, target, targetLen, terminate, termLen)
    }
    #[inline]
    pub unsafe fn parseInt(&mut self) -> libc::c_long {
        Stream_parseInt(self)
    }
    #[inline]
    pub unsafe fn parseFloat(&mut self) -> f32 { Stream_parseFloat(self) }
    #[inline]
    pub unsafe fn readBytesUntil(&mut self, terminator: libc::c_char,
                                 buffer: *mut libc::c_char, length: usize)
     -> usize {
        Stream_readBytesUntil(self, terminator, buffer, length)
    }
    #[inline]
    pub unsafe fn readString(&mut self) -> String { Stream_readString(self) }
    #[inline]
    pub unsafe fn readStringUntil(&mut self, terminator: libc::c_char)
     -> String {
        Stream_readStringUntil(self, terminator)
    }
    #[inline]
    pub unsafe fn parseInt1(&mut self, skipChar: libc::c_char)
     -> libc::c_long {
        Stream_parseInt1(self, skipChar)
    }
    #[inline]
    pub unsafe fn parseFloat1(&mut self, skipChar: libc::c_char) -> f32 {
        Stream_parseFloat1(self, skipChar)
    }
}
extern "C" {
    #[link_name = "_ZN6Stream9availableEv"]
    pub fn Stream_available(this: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN6Stream4readEv"]
    pub fn Stream_read(this: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN6Stream4peekEv"]
    pub fn Stream_peek(this: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN6Stream5flushEv"]
    pub fn Stream_flush(this: *mut libc::c_void);
}
extern "C" {
    #[link_name = "_ZN6Stream9readBytesEPcm"]
    pub fn Stream_readBytes(this: *mut libc::c_void,
                            buffer: *mut libc::c_char, length: usize)
     -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_ {
    _unused: [u8; 0],
}
pub type uart_t = uart_;
extern "C" {
    pub fn uart_init(uart_nr: libc::c_int, baudrate: libc::c_int,
                     config: libc::c_int, mode: libc::c_int,
                     tx_pin: libc::c_int, rx_size: usize) -> *mut uart_t;
}
extern "C" {
    pub fn uart_uninit(uart: *mut uart_t);
}
extern "C" {
    pub fn uart_swap(uart: *mut uart_t, tx_pin: libc::c_int);
}
extern "C" {
    pub fn uart_set_tx(uart: *mut uart_t, tx_pin: libc::c_int);
}
extern "C" {
    pub fn uart_set_pins(uart: *mut uart_t, tx: libc::c_int, rx: libc::c_int);
}
extern "C" {
    pub fn uart_tx_enabled(uart: *mut uart_t) -> bool;
}
extern "C" {
    pub fn uart_rx_enabled(uart: *mut uart_t) -> bool;
}
extern "C" {
    pub fn uart_set_baudrate(uart: *mut uart_t, baud_rate: libc::c_int);
}
extern "C" {
    pub fn uart_get_baudrate(uart: *mut uart_t) -> libc::c_int;
}
extern "C" {
    pub fn uart_resize_rx_buffer(uart: *mut uart_t, new_size: usize) -> usize;
}
extern "C" {
    pub fn uart_write_char(uart: *mut uart_t, c: libc::c_char);
}
extern "C" {
    pub fn uart_write(uart: *mut uart_t, buf: *const libc::c_char,
                      size: usize);
}
extern "C" {
    pub fn uart_read_char(uart: *mut uart_t) -> libc::c_int;
}
extern "C" {
    pub fn uart_peek_char(uart: *mut uart_t) -> libc::c_int;
}
extern "C" {
    pub fn uart_rx_available(uart: *mut uart_t) -> usize;
}
extern "C" {
    pub fn uart_tx_free(uart: *mut uart_t) -> usize;
}
extern "C" {
    pub fn uart_wait_tx_empty(uart: *mut uart_t);
}
extern "C" {
    pub fn uart_flush(uart: *mut uart_t);
}
extern "C" {
    pub fn uart_set_debug(uart_nr: libc::c_int);
}
extern "C" {
    pub fn uart_get_debug() -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SerialConfig {
    SERIAL_5N1 = 16,
    SERIAL_6N1 = 20,
    SERIAL_7N1 = 24,
    SERIAL_8N1 = 28,
    SERIAL_5N2 = 48,
    SERIAL_6N2 = 52,
    SERIAL_7N2 = 56,
    SERIAL_8N2 = 60,
    SERIAL_5E1 = 18,
    SERIAL_6E1 = 22,
    SERIAL_7E1 = 26,
    SERIAL_8E1 = 30,
    SERIAL_5E2 = 50,
    SERIAL_6E2 = 54,
    SERIAL_7E2 = 58,
    SERIAL_8E2 = 62,
    SERIAL_5O1 = 19,
    SERIAL_6O1 = 23,
    SERIAL_7O1 = 27,
    SERIAL_8O1 = 31,
    SERIAL_5O2 = 51,
    SERIAL_6O2 = 55,
    SERIAL_7O2 = 59,
    SERIAL_8O2 = 63,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SerialMode {
    SERIAL_FULL = 0,
    SERIAL_RX_ONLY = 1,
    SERIAL_TX_ONLY = 2,
}
#[repr(C)]
#[derive(Debug)]
pub struct HardwareSerial {
    pub _base: Stream,
    pub _uart_nr: libc::c_int,
    pub _uart: *mut uart_t,
    pub _rx_size: usize,
}
#[test]
fn bindgen_test_layout_HardwareSerial() {
    assert_eq!(::core::mem::size_of::<HardwareSerial>() , 56usize , concat ! (
               "Size of: " , stringify ! ( HardwareSerial ) ));
    assert_eq! (::core::mem::align_of::<HardwareSerial>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( HardwareSerial ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HardwareSerial ) ) . _uart_nr as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( HardwareSerial ) , "::"
                , stringify ! ( _uart_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HardwareSerial ) ) . _uart as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( HardwareSerial ) , "::"
                , stringify ! ( _uart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HardwareSerial ) ) . _rx_size as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( HardwareSerial ) , "::"
                , stringify ! ( _rx_size ) ));
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial5beginEm12SerialConfig10SerialModeh"]
    pub fn HardwareSerial_begin(this: *mut HardwareSerial,
                                baud: libc::c_ulong, config: SerialConfig,
                                mode: SerialMode, tx_pin: u8);
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial3endEv"]
    pub fn HardwareSerial_end(this: *mut HardwareSerial);
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial15setRxBufferSizeEm"]
    pub fn HardwareSerial_setRxBufferSize(this: *mut HardwareSerial,
                                          size: usize) -> usize;
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial4swapEh"]
    pub fn HardwareSerial_swap(this: *mut HardwareSerial, tx_pin: u8);
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial6set_txEh"]
    pub fn HardwareSerial_set_tx(this: *mut HardwareSerial, tx_pin: u8);
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial4pinsEhh"]
    pub fn HardwareSerial_pins(this: *mut HardwareSerial, tx: u8, rx: u8);
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial17availableForWriteEv"]
    pub fn HardwareSerial_availableForWrite(this: *mut HardwareSerial)
     -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial14setDebugOutputEb"]
    pub fn HardwareSerial_setDebugOutput(this: *mut HardwareSerial,
                                         arg1: bool);
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial11isTxEnabledEv"]
    pub fn HardwareSerial_isTxEnabled(this: *mut HardwareSerial) -> bool;
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial11isRxEnabledEv"]
    pub fn HardwareSerial_isRxEnabled(this: *mut HardwareSerial) -> bool;
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial8baudRateEv"]
    pub fn HardwareSerial_baudRate(this: *mut HardwareSerial) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN14HardwareSerialC1Ei"]
    pub fn HardwareSerial_HardwareSerial(this: *mut HardwareSerial,
                                         uart_nr: libc::c_int);
}
impl HardwareSerial {
    #[inline]
    pub unsafe fn begin(&mut self, baud: libc::c_ulong, config: SerialConfig,
                        mode: SerialMode, tx_pin: u8) {
        HardwareSerial_begin(self, baud, config, mode, tx_pin)
    }
    #[inline]
    pub unsafe fn end(&mut self) { HardwareSerial_end(self) }
    #[inline]
    pub unsafe fn setRxBufferSize(&mut self, size: usize) -> usize {
        HardwareSerial_setRxBufferSize(self, size)
    }
    #[inline]
    pub unsafe fn swap(&mut self, tx_pin: u8) {
        HardwareSerial_swap(self, tx_pin)
    }
    #[inline]
    pub unsafe fn set_tx(&mut self, tx_pin: u8) {
        HardwareSerial_set_tx(self, tx_pin)
    }
    #[inline]
    pub unsafe fn pins(&mut self, tx: u8, rx: u8) {
        HardwareSerial_pins(self, tx, rx)
    }
    #[inline]
    pub unsafe fn availableForWrite(&mut self) -> libc::c_int {
        HardwareSerial_availableForWrite(self)
    }
    #[inline]
    pub unsafe fn setDebugOutput(&mut self, arg1: bool) {
        HardwareSerial_setDebugOutput(self, arg1)
    }
    #[inline]
    pub unsafe fn isTxEnabled(&mut self) -> bool {
        HardwareSerial_isTxEnabled(self)
    }
    #[inline]
    pub unsafe fn isRxEnabled(&mut self) -> bool {
        HardwareSerial_isRxEnabled(self)
    }
    #[inline]
    pub unsafe fn baudRate(&mut self) -> libc::c_int {
        HardwareSerial_baudRate(self)
    }
    #[inline]
    pub unsafe fn new(uart_nr: libc::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        HardwareSerial_HardwareSerial(&mut __bindgen_tmp, uart_nr);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial9availableEv"]
    pub fn HardwareSerial_available(this: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial4peekEv"]
    pub fn HardwareSerial_peek(this: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial4readEv"]
    pub fn HardwareSerial_read(this: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial5flushEv"]
    pub fn HardwareSerial_flush(this: *mut libc::c_void);
}
extern "C" {
    #[link_name = "_ZN14HardwareSerial5writeEh"]
    pub fn HardwareSerial_write(this: *mut libc::c_void, arg1: u8) -> usize;
}
extern "C" {
    #[link_name = "Serial"]
    pub static mut Serial: HardwareSerial;
}
extern "C" {
    #[link_name = "Serial1"]
    pub static mut Serial1: HardwareSerial;
}
extern "C" {
    pub fn SPIEraseBlock(block: u32) -> libc::c_int;
}
extern "C" {
    pub fn SPIEraseSector(sector: u32) -> libc::c_int;
}
extern "C" {
    pub fn SPIRead(addr: u32, dest: *mut libc::c_void, size: usize)
     -> libc::c_int;
}
extern "C" {
    pub fn SPIWrite(addr: u32, src: *mut libc::c_void, size: usize)
     -> libc::c_int;
}
extern "C" {
    pub fn SPIEraseAreaEx(start: u32, size: u32) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct image_header_t {
    pub magic: libc::c_uchar,
    pub num_segments: libc::c_uchar,
    pub flash_mode: libc::c_uchar,
    pub flash_size_freq: libc::c_uchar,
    pub entry: u32,
}
#[test]
fn bindgen_test_layout_image_header_t() {
    assert_eq!(::core::mem::size_of::<image_header_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( image_header_t ) ));
    assert_eq! (::core::mem::align_of::<image_header_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( image_header_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_header_t ) ) . magic as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( image_header_t ) , "::"
                , stringify ! ( magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_header_t ) ) . num_segments as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( image_header_t ) , "::"
                , stringify ! ( num_segments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_header_t ) ) . flash_mode as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( image_header_t ) , "::"
                , stringify ! ( flash_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_header_t ) ) . flash_size_freq as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( image_header_t ) , "::"
                , stringify ! ( flash_size_freq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const image_header_t ) ) . entry as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( image_header_t ) , "::"
                , stringify ! ( entry ) ));
}
impl Clone for image_header_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct section_header_t {
    pub address: u32,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_section_header_t() {
    assert_eq!(::core::mem::size_of::<section_header_t>() , 8usize , concat !
               ( "Size of: " , stringify ! ( section_header_t ) ));
    assert_eq! (::core::mem::align_of::<section_header_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( section_header_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const section_header_t ) ) . address as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( section_header_t ) ,
                "::" , stringify ! ( address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const section_header_t ) ) . size as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( section_header_t ) ,
                "::" , stringify ! ( size ) ));
}
impl Clone for section_header_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct md5_context_t {
    pub state: [u32; 4usize],
    pub count: [u32; 2usize],
    pub buffer: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_md5_context_t() {
    assert_eq!(::core::mem::size_of::<md5_context_t>() , 88usize , concat ! (
               "Size of: " , stringify ! ( md5_context_t ) ));
    assert_eq! (::core::mem::align_of::<md5_context_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( md5_context_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md5_context_t ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( md5_context_t ) , "::"
                , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md5_context_t ) ) . count as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( md5_context_t ) , "::"
                , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md5_context_t ) ) . buffer as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( md5_context_t ) , "::"
                , stringify ! ( buffer ) ));
}
impl Clone for md5_context_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn MD5Init(arg1: *mut md5_context_t);
}
extern "C" {
    pub fn MD5Update(arg1: *mut md5_context_t, arg2: *const u8, arg3: u16);
}
extern "C" {
    pub fn MD5Final(arg1: *mut u8, arg2: *mut md5_context_t);
}
#[repr(C)]
#[derive(Copy)]
pub struct MD5Builder {
    pub _ctx: md5_context_t,
    pub _buf: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_MD5Builder() {
    assert_eq!(::core::mem::size_of::<MD5Builder>() , 104usize , concat ! (
               "Size of: " , stringify ! ( MD5Builder ) ));
    assert_eq! (::core::mem::align_of::<MD5Builder>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( MD5Builder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MD5Builder ) ) . _ctx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MD5Builder ) , "::" ,
                stringify ! ( _ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MD5Builder ) ) . _buf as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( MD5Builder ) , "::" ,
                stringify ! ( _buf ) ));
}
extern "C" {
    #[link_name = "_ZN10MD5Builder5beginEv"]
    pub fn MD5Builder_begin(this: *mut MD5Builder);
}
extern "C" {
    #[link_name = "_ZN10MD5Builder3addEPKht"]
    pub fn MD5Builder_add(this: *mut MD5Builder, data: *const u8, len: u16);
}
extern "C" {
    #[link_name = "_ZN10MD5Builder12addHexStringEPKc"]
    pub fn MD5Builder_addHexString(this: *mut MD5Builder,
                                   data: *const libc::c_char);
}
extern "C" {
    #[link_name = "_ZN10MD5Builder9addStreamER6Streamm"]
    pub fn MD5Builder_addStream(this: *mut MD5Builder, stream: *mut Stream,
                                maxLen: usize) -> bool;
}
extern "C" {
    #[link_name = "_ZN10MD5Builder9calculateEv"]
    pub fn MD5Builder_calculate(this: *mut MD5Builder);
}
extern "C" {
    #[link_name = "_ZN10MD5Builder8getBytesEPh"]
    pub fn MD5Builder_getBytes(this: *mut MD5Builder, output: *mut u8);
}
extern "C" {
    #[link_name = "_ZN10MD5Builder8getCharsEPc"]
    pub fn MD5Builder_getChars(this: *mut MD5Builder,
                               output: *mut libc::c_char);
}
extern "C" {
    #[link_name = "_ZN10MD5Builder8toStringEv"]
    pub fn MD5Builder_toString(this: *mut MD5Builder) -> String;
}
impl Clone for MD5Builder {
    fn clone(&self) -> Self { *self }
}
impl MD5Builder {
    #[inline]
    pub unsafe fn begin(&mut self) { MD5Builder_begin(self) }
    #[inline]
    pub unsafe fn add(&mut self, data: *const u8, len: u16) {
        MD5Builder_add(self, data, len)
    }
    #[inline]
    pub unsafe fn addHexString(&mut self, data: *const libc::c_char) {
        MD5Builder_addHexString(self, data)
    }
    #[inline]
    pub unsafe fn addStream(&mut self, stream: *mut Stream, maxLen: usize)
     -> bool {
        MD5Builder_addStream(self, stream, maxLen)
    }
    #[inline]
    pub unsafe fn calculate(&mut self) { MD5Builder_calculate(self) }
    #[inline]
    pub unsafe fn getBytes(&mut self, output: *mut u8) {
        MD5Builder_getBytes(self, output)
    }
    #[inline]
    pub unsafe fn getChars(&mut self, output: *mut libc::c_char) {
        MD5Builder_getChars(self, output)
    }
    #[inline]
    pub unsafe fn toString(&mut self) -> String { MD5Builder_toString(self) }
}
#[repr(C)]
pub struct UpdaterClass {
    pub _async: bool,
    pub _error: u8,
    pub _buffer: *mut u8,
    pub _bufferLen: usize,
    pub _bufferSize: usize,
    pub _size: usize,
    pub _startAddress: u32,
    pub _currentAddress: u32,
    pub _command: u32,
    pub _target_md5: String,
    pub _md5: MD5Builder,
}
#[test]
fn bindgen_test_layout_UpdaterClass() {
    assert_eq!(::core::mem::size_of::<UpdaterClass>() , 176usize , concat ! (
               "Size of: " , stringify ! ( UpdaterClass ) ));
    assert_eq! (::core::mem::align_of::<UpdaterClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( UpdaterClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _async as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _async ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _error as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _buffer as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _bufferLen as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _bufferLen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _bufferSize as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _bufferSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _size as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _startAddress as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _startAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _currentAddress as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _currentAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _command as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _command ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _target_md5 as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _target_md5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UpdaterClass ) ) . _md5 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( UpdaterClass ) , "::" ,
                stringify ! ( _md5 ) ));
}
extern "C" {
    #[link_name = "_ZN12UpdaterClass5beginEmi"]
    pub fn UpdaterClass_begin(this: *mut UpdaterClass, size: usize,
                              command: libc::c_int) -> bool;
}
extern "C" {
    #[link_name = "_ZN12UpdaterClass5writeEPhm"]
    pub fn UpdaterClass_write(this: *mut UpdaterClass, data: *mut u8,
                              len: usize) -> usize;
}
extern "C" {
    #[link_name = "_ZN12UpdaterClass11writeStreamER6Stream"]
    pub fn UpdaterClass_writeStream(this: *mut UpdaterClass,
                                    data: *mut Stream) -> usize;
}
extern "C" {
    #[link_name = "_ZN12UpdaterClass3endEb"]
    pub fn UpdaterClass_end(this: *mut UpdaterClass, evenIfRemaining: bool)
     -> bool;
}
extern "C" {
    #[link_name = "_ZN12UpdaterClass10printErrorER6Stream"]
    pub fn UpdaterClass_printError(this: *mut UpdaterClass, out: *mut Stream);
}
extern "C" {
    #[link_name = "_ZN12UpdaterClass6setMD5EPKc"]
    pub fn UpdaterClass_setMD5(this: *mut UpdaterClass,
                               expected_md5: *const libc::c_char) -> bool;
}
extern "C" {
    #[link_name = "_ZN12UpdaterClassC1Ev"]
    pub fn UpdaterClass_UpdaterClass(this: *mut UpdaterClass);
}
impl UpdaterClass {
    #[inline]
    pub unsafe fn begin(&mut self, size: usize, command: libc::c_int)
     -> bool {
        UpdaterClass_begin(self, size, command)
    }
    #[inline]
    pub unsafe fn write(&mut self, data: *mut u8, len: usize) -> usize {
        UpdaterClass_write(self, data, len)
    }
    #[inline]
    pub unsafe fn writeStream(&mut self, data: *mut Stream) -> usize {
        UpdaterClass_writeStream(self, data)
    }
    #[inline]
    pub unsafe fn end(&mut self, evenIfRemaining: bool) -> bool {
        UpdaterClass_end(self, evenIfRemaining)
    }
    #[inline]
    pub unsafe fn printError(&mut self, out: *mut Stream) {
        UpdaterClass_printError(self, out)
    }
    #[inline]
    pub unsafe fn setMD5(&mut self, expected_md5: *const libc::c_char)
     -> bool {
        UpdaterClass_setMD5(self, expected_md5)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::uninitialized();
        UpdaterClass_UpdaterClass(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "Update"]
    pub static mut Update: UpdaterClass;
}
extern "C" {
    #[link_name = "_Z7hexdumpPhjh"]
    pub fn hexdump(mem: *mut u8, len: u32, cols: u8);
}
extern "C" {
    pub fn __panic_func(file: *const libc::c_char, line: libc::c_int,
                        func: *const libc::c_char);
}
extern "C" {
    #[link_name = "_Z8makeWordt"]
    pub fn makeWord(w: u16) -> u16;
}
extern "C" {
    #[link_name = "_Z8makeWordhh"]
    pub fn makeWord1(h: byte, l: byte) -> u16;
}
extern "C" {
    #[link_name = "_Z4tonehjm"]
    pub fn tone(_pin: u8, frequency: libc::c_uint, duration: libc::c_ulong);
}
extern "C" {
    #[link_name = "_Z6noToneh"]
    pub fn noTone(_pin: u8);
}
extern "C" {
    #[link_name = "_Z6randoml"]
    pub fn random(arg1: libc::c_long) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z6randomll"]
    pub fn random1(arg1: libc::c_long, arg2: libc::c_long) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z10randomSeedm"]
    pub fn randomSeed(arg1: libc::c_ulong);
}
extern "C" {
    #[link_name = "_Z12secureRandoml"]
    pub fn secureRandom(arg1: libc::c_long) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z12secureRandomll"]
    pub fn secureRandom1(arg1: libc::c_long, arg2: libc::c_long)
     -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z3maplllll"]
    pub fn map(arg1: libc::c_long, arg2: libc::c_long, arg3: libc::c_long,
               arg4: libc::c_long, arg5: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn configTime(timezone: libc::c_long, daylightOffset_sec: libc::c_int,
                      server1: *const libc::c_char,
                      server2: *const libc::c_char,
                      server3: *const libc::c_char);
}
pub const SS: u8 = 15;
pub const MOSI: u8 = 13;
pub const MISO: u8 = 12;
pub const SCK: u8 = 14;
pub const A0: u8 = 17;
pub const SDA: u8 = 4;
pub const SCL: u8 = 5;
pub const LED_BUILTIN: u8 = 16;
pub const BUILTIN_LED: u8 = 16;
pub const D0: u8 = 16;
pub const D1: u8 = 5;
pub const D2: u8 = 4;
pub const D3: u8 = 0;
pub const D4: u8 = 2;
pub const D5: u8 = 14;
pub const D6: u8 = 12;
pub const D7: u8 = 13;
pub const D8: u8 = 15;
pub const D9: u8 = 3;
pub const D10: u8 = 1;
#[repr(u32)]
/// AVR macros for WDT managment
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WDTO_t {
    WDTO_0MS = 0,
    WDTO_15MS = 15,
    WDTO_30MS = 30,
    WDTO_60MS = 60,
    WDTO_120MS = 120,
    WDTO_250MS = 250,
    WDTO_500MS = 500,
    WDTO_1S = 1000,
    WDTO_2S = 2000,
    WDTO_4S = 4000,
    WDTO_8S = 8000,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RFMode {
    RF_DEFAULT = 0,
    RF_CAL = 1,
    RF_NO_CAL = 2,
    RF_DISABLED = 4,
}
pub const ADCMode_ADC_TOUT_3V3: ADCMode = ADCMode::ADC_TOUT;
pub const ADCMode_ADC_VDD: ADCMode = ADCMode::ADC_VCC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ADCMode { ADC_TOUT = 33, ADC_VCC = 255, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FlashMode_t {
    FM_QIO = 0,
    FM_QOUT = 1,
    FM_DIO = 2,
    FM_DOUT = 3,
    FM_UNKNOWN = 255,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EspClass {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_EspClass() {
    assert_eq!(::core::mem::size_of::<EspClass>() , 1usize , concat ! (
               "Size of: " , stringify ! ( EspClass ) ));
    assert_eq! (::core::mem::align_of::<EspClass>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( EspClass ) ));
}
extern "C" {
    #[link_name = "_ZN8EspClass9wdtEnableEj"]
    pub fn EspClass_wdtEnable(this: *mut EspClass, timeout_ms: u32);
}
extern "C" {
    #[link_name = "_ZN8EspClass9wdtEnableE6WDTO_t"]
    pub fn EspClass_wdtEnable1(this: *mut EspClass, timeout_ms: WDTO_t);
}
extern "C" {
    #[link_name = "_ZN8EspClass10wdtDisableEv"]
    pub fn EspClass_wdtDisable(this: *mut EspClass);
}
extern "C" {
    #[link_name = "_ZN8EspClass7wdtFeedEv"]
    pub fn EspClass_wdtFeed(this: *mut EspClass);
}
extern "C" {
    #[link_name = "_ZN8EspClass9deepSleepEj6RFMode"]
    pub fn EspClass_deepSleep(this: *mut EspClass, time_us: u32,
                              mode: RFMode);
}
extern "C" {
    #[link_name = "_ZN8EspClass17rtcUserMemoryReadEjPjm"]
    pub fn EspClass_rtcUserMemoryRead(this: *mut EspClass, offset: u32,
                                      data: *mut u32, size: usize) -> bool;
}
extern "C" {
    #[link_name = "_ZN8EspClass18rtcUserMemoryWriteEjPjm"]
    pub fn EspClass_rtcUserMemoryWrite(this: *mut EspClass, offset: u32,
                                       data: *mut u32, size: usize) -> bool;
}
extern "C" {
    #[link_name = "_ZN8EspClass5resetEv"]
    pub fn EspClass_reset(this: *mut EspClass);
}
extern "C" {
    #[link_name = "_ZN8EspClass7restartEv"]
    pub fn EspClass_restart(this: *mut EspClass);
}
extern "C" {
    #[link_name = "_ZN8EspClass6getVccEv"]
    pub fn EspClass_getVcc(this: *mut EspClass) -> u16;
}
extern "C" {
    #[link_name = "_ZN8EspClass11getFreeHeapEv"]
    pub fn EspClass_getFreeHeap(this: *mut EspClass) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass9getChipIdEv"]
    pub fn EspClass_getChipId(this: *mut EspClass) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass13getSdkVersionEv"]
    pub fn EspClass_getSdkVersion(this: *mut EspClass) -> *const libc::c_char;
}
extern "C" {
    #[link_name = "_ZN8EspClass14getCoreVersionEv"]
    pub fn EspClass_getCoreVersion(this: *mut EspClass) -> String;
}
extern "C" {
    #[link_name = "_ZN8EspClass14getBootVersionEv"]
    pub fn EspClass_getBootVersion(this: *mut EspClass) -> u8;
}
extern "C" {
    #[link_name = "_ZN8EspClass11getBootModeEv"]
    pub fn EspClass_getBootMode(this: *mut EspClass) -> u8;
}
extern "C" {
    #[link_name = "_ZN8EspClass13getCpuFreqMHzEv"]
    pub fn EspClass_getCpuFreqMHz(this: *mut EspClass) -> u8;
}
extern "C" {
    #[link_name = "_ZN8EspClass14getFlashChipIdEv"]
    pub fn EspClass_getFlashChipId(this: *mut EspClass) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass20getFlashChipRealSizeEv"]
    pub fn EspClass_getFlashChipRealSize(this: *mut EspClass) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass16getFlashChipSizeEv"]
    pub fn EspClass_getFlashChipSize(this: *mut EspClass) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass17getFlashChipSpeedEv"]
    pub fn EspClass_getFlashChipSpeed(this: *mut EspClass) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass16getFlashChipModeEv"]
    pub fn EspClass_getFlashChipMode(this: *mut EspClass) -> FlashMode_t;
}
extern "C" {
    #[link_name = "_ZN8EspClass24getFlashChipSizeByChipIdEv"]
    pub fn EspClass_getFlashChipSizeByChipId(this: *mut EspClass) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass18magicFlashChipSizeEh"]
    pub fn EspClass_magicFlashChipSize(this: *mut EspClass, byte: u8) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass19magicFlashChipSpeedEh"]
    pub fn EspClass_magicFlashChipSpeed(this: *mut EspClass, byte: u8) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass18magicFlashChipModeEh"]
    pub fn EspClass_magicFlashChipMode(this: *mut EspClass, byte: u8)
     -> FlashMode_t;
}
extern "C" {
    #[link_name = "_ZN8EspClass16checkFlashConfigEb"]
    pub fn EspClass_checkFlashConfig(this: *mut EspClass, needsEquals: bool)
     -> bool;
}
extern "C" {
    #[link_name = "_ZN8EspClass16flashEraseSectorEj"]
    pub fn EspClass_flashEraseSector(this: *mut EspClass, sector: u32)
     -> bool;
}
extern "C" {
    #[link_name = "_ZN8EspClass10flashWriteEjPjm"]
    pub fn EspClass_flashWrite(this: *mut EspClass, offset: u32,
                               data: *mut u32, size: usize) -> bool;
}
extern "C" {
    #[link_name = "_ZN8EspClass9flashReadEjPjm"]
    pub fn EspClass_flashRead(this: *mut EspClass, offset: u32,
                              data: *mut u32, size: usize) -> bool;
}
extern "C" {
    #[link_name = "_ZN8EspClass13getSketchSizeEv"]
    pub fn EspClass_getSketchSize(this: *mut EspClass) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass12getSketchMD5Ev"]
    pub fn EspClass_getSketchMD5(this: *mut EspClass) -> String;
}
extern "C" {
    #[link_name = "_ZN8EspClass18getFreeSketchSpaceEv"]
    pub fn EspClass_getFreeSketchSpace(this: *mut EspClass) -> u32;
}
extern "C" {
    #[link_name = "_ZN8EspClass12updateSketchER6Streamjbb"]
    pub fn EspClass_updateSketch(this: *mut EspClass, in_: *mut Stream,
                                 size: u32, restartOnFail: bool,
                                 restartOnSuccess: bool) -> bool;
}
extern "C" {
    #[link_name = "_ZN8EspClass14getResetReasonEv"]
    pub fn EspClass_getResetReason(this: *mut EspClass) -> String;
}
extern "C" {
    #[link_name = "_ZN8EspClass12getResetInfoEv"]
    pub fn EspClass_getResetInfo(this: *mut EspClass) -> String;
}
extern "C" {
    #[link_name = "_ZN8EspClass15getResetInfoPtrEv"]
    pub fn EspClass_getResetInfoPtr(this: *mut EspClass) -> *mut rst_info;
}
extern "C" {
    #[link_name = "_ZN8EspClass11eraseConfigEv"]
    pub fn EspClass_eraseConfig(this: *mut EspClass) -> bool;
}
impl Clone for EspClass {
    fn clone(&self) -> Self { *self }
}
impl EspClass {
    #[inline]
    pub unsafe fn wdtEnable(&mut self, timeout_ms: u32) {
        EspClass_wdtEnable(self, timeout_ms)
    }
    #[inline]
    pub unsafe fn wdtEnable1(&mut self, timeout_ms: WDTO_t) {
        EspClass_wdtEnable1(self, timeout_ms)
    }
    #[inline]
    pub unsafe fn wdtDisable(&mut self) { EspClass_wdtDisable(self) }
    #[inline]
    pub unsafe fn wdtFeed(&mut self) { EspClass_wdtFeed(self) }
    #[inline]
    pub unsafe fn deepSleep(&mut self, time_us: u32, mode: RFMode) {
        EspClass_deepSleep(self, time_us, mode)
    }
    #[inline]
    pub unsafe fn rtcUserMemoryRead(&mut self, offset: u32, data: *mut u32,
                                    size: usize) -> bool {
        EspClass_rtcUserMemoryRead(self, offset, data, size)
    }
    #[inline]
    pub unsafe fn rtcUserMemoryWrite(&mut self, offset: u32, data: *mut u32,
                                     size: usize) -> bool {
        EspClass_rtcUserMemoryWrite(self, offset, data, size)
    }
    #[inline]
    pub unsafe fn reset(&mut self) { EspClass_reset(self) }
    #[inline]
    pub unsafe fn restart(&mut self) { EspClass_restart(self) }
    #[inline]
    pub unsafe fn getVcc(&mut self) -> u16 { EspClass_getVcc(self) }
    #[inline]
    pub unsafe fn getFreeHeap(&mut self) -> u32 { EspClass_getFreeHeap(self) }
    #[inline]
    pub unsafe fn getChipId(&mut self) -> u32 { EspClass_getChipId(self) }
    #[inline]
    pub unsafe fn getSdkVersion(&mut self) -> *const libc::c_char {
        EspClass_getSdkVersion(self)
    }
    #[inline]
    pub unsafe fn getCoreVersion(&mut self) -> String {
        EspClass_getCoreVersion(self)
    }
    #[inline]
    pub unsafe fn getBootVersion(&mut self) -> u8 {
        EspClass_getBootVersion(self)
    }
    #[inline]
    pub unsafe fn getBootMode(&mut self) -> u8 { EspClass_getBootMode(self) }
    #[inline]
    pub unsafe fn getCpuFreqMHz(&mut self) -> u8 {
        EspClass_getCpuFreqMHz(self)
    }
    #[inline]
    pub unsafe fn getFlashChipId(&mut self) -> u32 {
        EspClass_getFlashChipId(self)
    }
    #[inline]
    pub unsafe fn getFlashChipRealSize(&mut self) -> u32 {
        EspClass_getFlashChipRealSize(self)
    }
    #[inline]
    pub unsafe fn getFlashChipSize(&mut self) -> u32 {
        EspClass_getFlashChipSize(self)
    }
    #[inline]
    pub unsafe fn getFlashChipSpeed(&mut self) -> u32 {
        EspClass_getFlashChipSpeed(self)
    }
    #[inline]
    pub unsafe fn getFlashChipMode(&mut self) -> FlashMode_t {
        EspClass_getFlashChipMode(self)
    }
    #[inline]
    pub unsafe fn getFlashChipSizeByChipId(&mut self) -> u32 {
        EspClass_getFlashChipSizeByChipId(self)
    }
    #[inline]
    pub unsafe fn magicFlashChipSize(&mut self, byte: u8) -> u32 {
        EspClass_magicFlashChipSize(self, byte)
    }
    #[inline]
    pub unsafe fn magicFlashChipSpeed(&mut self, byte: u8) -> u32 {
        EspClass_magicFlashChipSpeed(self, byte)
    }
    #[inline]
    pub unsafe fn magicFlashChipMode(&mut self, byte: u8) -> FlashMode_t {
        EspClass_magicFlashChipMode(self, byte)
    }
    #[inline]
    pub unsafe fn checkFlashConfig(&mut self, needsEquals: bool) -> bool {
        EspClass_checkFlashConfig(self, needsEquals)
    }
    #[inline]
    pub unsafe fn flashEraseSector(&mut self, sector: u32) -> bool {
        EspClass_flashEraseSector(self, sector)
    }
    #[inline]
    pub unsafe fn flashWrite(&mut self, offset: u32, data: *mut u32,
                             size: usize) -> bool {
        EspClass_flashWrite(self, offset, data, size)
    }
    #[inline]
    pub unsafe fn flashRead(&mut self, offset: u32, data: *mut u32,
                            size: usize) -> bool {
        EspClass_flashRead(self, offset, data, size)
    }
    #[inline]
    pub unsafe fn getSketchSize(&mut self) -> u32 {
        EspClass_getSketchSize(self)
    }
    #[inline]
    pub unsafe fn getSketchMD5(&mut self) -> String {
        EspClass_getSketchMD5(self)
    }
    #[inline]
    pub unsafe fn getFreeSketchSpace(&mut self) -> u32 {
        EspClass_getFreeSketchSpace(self)
    }
    #[inline]
    pub unsafe fn updateSketch(&mut self, in_: *mut Stream, size: u32,
                               restartOnFail: bool, restartOnSuccess: bool)
     -> bool {
        EspClass_updateSketch(self, in_, size, restartOnFail,
                              restartOnSuccess)
    }
    #[inline]
    pub unsafe fn getResetReason(&mut self) -> String {
        EspClass_getResetReason(self)
    }
    #[inline]
    pub unsafe fn getResetInfo(&mut self) -> String {
        EspClass_getResetInfo(self)
    }
    #[inline]
    pub unsafe fn getResetInfoPtr(&mut self) -> *mut rst_info {
        EspClass_getResetInfoPtr(self)
    }
    #[inline]
    pub unsafe fn eraseConfig(&mut self) -> bool {
        EspClass_eraseConfig(self)
    }
}
extern "C" {
    #[link_name = "ESP"]
    pub static mut ESP: EspClass;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rst_info {
    pub _address: u8,
}
impl Clone for rst_info {
    fn clone(&self) -> Self { *self }
}
